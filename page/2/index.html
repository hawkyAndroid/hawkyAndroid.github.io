<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hawky的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="爱好爬山、旅游、分享">
<meta property="og:type" content="website">
<meta property="og:title" content="Hawky的博客">
<meta property="og:url" content="http://hawkyAndroid.github.io/page/2/index.html">
<meta property="og:site_name" content="Hawky的博客">
<meta property="og:description" content="爱好爬山、旅游、分享">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hawky的博客">
<meta name="twitter:description" content="爱好爬山、旅游、分享">
  
    <link rel="alternate" href="/atom.xml" title="Hawky的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hawky的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">行到水穷处，坐看云起时</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hawkyAndroid.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-原-Java学习系列-二十-Java面向对象之反射详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/26/原-Java学习系列-二十-Java面向对象之反射详解/" class="article-date">
  <time datetime="2015-04-26T10:46:31.000Z" itemprop="datePublished">2015-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/26/原-Java学习系列-二十-Java面向对象之反射详解/">[原]Java学习系列(二十)Java面向对象之反射详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="color:rgb(255,0,0); font-family:Arial; font-size:18px; line-height:26px; text-align:left">转载请注明出处：</span><a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40019829" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40021651" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40027109" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/45289391" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/45289391</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天讲讲Java中的反射。我们常见的反射多用于JDBC中的加载驱动程序Class.forName(&quot;com.mysql.jdbc.Driver&quot;);、Struts的MVC、Hibernate中的ORM、Spring中的IOC还有一些其他框架等等。那它有什么好处呢？它的好处就是能够动态的创建对象和编译且能够访问某个类中的所有(包括私有)属性方法及对象的属性方法并进行调用，比较灵活，这样也有利于降低类间的耦合度；但反射也有缺点，就是破坏了类的封装性和对象的完整性。</p>
<h1 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h1><div><pre code_snippet_id="653473" snippet_file_name="blog_20150426_1_9374736" name="code" class="java">/<strong><br> <em> 目标类
 </em><br> <em> @author [</em>昨日重现<em>] lhy_ycu@163.com
 </em> @since version 1.0<br> <em> @datetime 2015年4月26日 下午4:50:28
 </em>/<br><br>public class Student {<br>    private String name;<br>    private Integer age;<br><br>    /</strong><br>     <em> 无参构造并赋默认值
     </em>/<br>    public Student() {<br>        this.name = &quot;张三&quot;;<br>        this.age = 22;<br>    }<br><br>    public Student(String name, Integer age) {<br>        this.name = name;<br>        this.age = age;<br>    }<br><br>    public String getName() {<br>        return name;<br>    }<br><br>    public void setName(String name) {<br>        this.name = name;<br>    }<br><br>    public Integer getAge() {<br>        return age;<br>    }<br><br>    public void setAge(Integer age) {<br>        this.age = age;<br>    }<br><br>    public void info() {<br>        System.out.println(&quot;做一个快乐的程序员~&quot; + this);<br>    }<br><br>    private void joke() {<br>        System.out.println(&quot;开个玩笑啦。。。&quot;);<br>    }<br><br>    // 无参<br>    public void play() {<br>        System.out.println(this.name + &quot; is playing…&quot;);<br>    }<br><br>    // 重载play<br>    public void play(String name) {<br>        System.out.println(this.name + &quot; is playing xx with &quot; + name);<br>    }<br><br>    /<strong><br>     <em> getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
     </em> 推荐实体类都覆写toString方法，方便查看日志信息<br>     <em> 
     </em> @return<br>     <em> @see java.lang.Object#toString()
     </em>/<br>    @Override<br>    public String toString() {<br>        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;<br>    }<br><br>}<br></strong></pre><br><br>目标测试类</div><br><div><pre code_snippet_id="653473" snippet_file_name="blog_20150426_2_1453736" name="code" class="java">/<br> <em> 利用反射对目标类进行测试
 </em><br> <em> @author [</em>昨日重现<em>] lhy_ycu@163.com
 </em> @since version 1.0<br> <em> @datetime 2015年4月26日 下午5:14:52
 </em>/<br><br>public class StudentTest {<br><br>    @BeforeClass<br>    public static void beforeClass() {<br>        System.out.println(&quot;=========在所有测试方法执行前执行–beforeClass=====\n&quot;);<br>    }<br><br>    /<strong><br>     <em> 1、Class.forName(&quot;类的完整路径&quot;)；2、Student.class；3、obj.getClass()
     </em><br>     <em> @throws Exception
     </em>/<br>    @Test<br>    public void testInfo() throws Exception {<br>        Class&lt;?&gt; c1 = Class.forName(&quot;com.leo.reflection.Student&quot;);<br>        // Class&lt;?&gt; c1 = Student.class;<br>        // 获取其实例,newInstance()会默认调用无参构造器，因此需要目标类保留无参的构造器<br>        Student s1 = (Student) c1.newInstance();<br>        // System.out.println(&quot;s1 = &quot; + s1.getClass().getCanonicalName());<br>        s1.info();<br>        int age = s1.getAge();<br>        String name = s1.getName();<br>        Assert.assertThat(age, Matchers.is(22));// normal<br>        Assert.assertThat(name, Matchers.is(&quot;李四&quot;));// failure<br>    }<br><br>    /</strong><br>     <em> 通过类的加载器来获取某个类
     </em><br>     <em> @throws Exception
     </em>/<br>    @Test<br>    public void testInfo2() throws Exception {<br>        // 获取一个类加载器<br>        ClassLoader cl = ClassLoader.getSystemClassLoader();<br>        // 加载指定的类<br>        Class&lt;?&gt; clazz = cl.loadClass(&quot;com.leo.reflection.Student&quot;);<br>        // System.out.println(clazz.getName());<br>        Student s1 = (Student) clazz.newInstance();<br>        s1.info();<br>    }<br><br>    /<strong><br>     <em> 访问构造器
     </em><br>     <em> @throws Exception
     </em>/<br>    @Test<br>    public void testConstruction() throws Exception {<br>        Class&lt;?&gt; c1 = Class.forName(&quot;com.leo.reflection.Student&quot;);<br>        // 获取带有指定参数列表的构造方法的Constructor对象<br>        Constructor&lt;?&gt; cs = c1.getDeclaredConstructor(String.class,<br>                Integer.class);<br>        Student s1 = (Student) cs.newInstance(&quot;小四&quot;, 24);<br>        s1.info();<br><br>        // 获取指定类的所有构造器<br>        // Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors();<br>        // for (Constructor&lt;?&gt; constructor : constructors) {<br>        // System.out.println(&quot;constructor = &quot; + constructor);<br>        // }<br>    }<br><br>    /</strong><br>     <em> 访问属性(包括私有属性)
     </em><br>     <em> @throws Exception
     </em>/<br>    @Test<br>    public void testField() throws Exception {<br>        Class&lt;?&gt; c1 = Class.forName(&quot;com.leo.reflection.Student&quot;);<br>        Student s1 = (Student) c1.newInstance();<br><br>        // 获取某个属性<br>        Field field = c1.getDeclaredField(&quot;name&quot;);<br>        // 该属性设置为可访问<br>        field.setAccessible(true);<br>        System.out.println(&quot;field = &quot; + field + &quot; , &quot; + field.get(s1));<br><br>        // 获取指定类的所有属性<br>        // Field[] fields = c1.getDeclaredFields();<br>        // for (Field f : fields) {<br>        // f.setAccessible(true);<br>        // System.out.println(f.getName() + &quot; = &quot; + f.get(s1));<br>        // }<br><br>    }<br><br>    /<em>*
     </em> 访问方法(包括私有方法)<br>     <em> 
     </em> @throws Exception<br>     */<br>    @Test<br>    public void testMethod() throws Exception {<br>        Class&lt;?&gt; c1 = Class.forName(&quot;com.leo.reflection.Student&quot;);<br>        Student s1 = (Student) c1.newInstance();<br><br>        // 获取某个类的指定无参方法<br>        Method m1 = c1.getDeclaredMethod(&quot;play&quot;);<br>        m1.invoke(s1);<br><br>        // 获取某个类的指定含参方法<br>        Method m2 = c1.getDeclaredMethod(&quot;play&quot;, String.class);<br>        m2.invoke(s1, &quot;钱七&quot;);<br><br>        System.out.println(&quot;=======================&quot;);<br>        // 获取指定类的所有方法<br>        // Method[] methods = c1.getDeclaredMethods();<br>        // for (Method method : methods) {<br>        // method.setAccessible(true);<br>        // System.out.println(method.getName());<br>        // }<br>        // System.out.println(&quot;=======================\n&quot;);<br><br>    }<br><br>    @AfterClass<br>    public static void afterClass() {<br>        System.out.println(&quot;==========在所有测试方法执行后执行–afterClass=====\n&quot;);<br>    }<br><br>}</pre></div><br><div><img src="http://img.blog.csdn.net/20150426184514636?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></div><br><div><br><br></div><br><div><br><br></div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div>1、所有类的对象其实都是Class的实例。</div><br><div>2、Class实例化其他类的对象的时候，一定要保留默认的无参构造函数。 &nbsp;&nbsp;</div><br><div>3、加载某个类的3种常用方式：a) Class.forName(&quot;类的完整路径&quot;)、b) 类名.class、c) obj.getClass()</div><br><div>4、反射的常用的两步：Class&lt;?&gt; c1 = Class.forName(&quot;类的完整路径&quot;);&nbsp;T1 &nbsp;t = (T1) c1.newInstance();</div>

<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2015/4/26 18:46:31 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/45289391)
&lt;/div&gt;
&lt;div&gt;
阅读：965 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/45289391#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2015/04/26/原-Java学习系列-二十-Java面向对象之反射详解/" data-id="cj8ynscod0008o49z3fvgcigh" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2015/04/26/原-Java学习系列-二十-Java面向对象之反射详解/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-基于Junit3-8和Junit4-x的单元测试详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/26/原-基于Junit3-8和Junit4-x的单元测试详解/" class="article-date">
  <time datetime="2015-04-25T18:14:10.000Z" itemprop="datePublished">2015-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/26/原-基于Junit3-8和Junit4-x的单元测试详解/">[原]基于Junit3.8和Junit4.x的单元测试详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="color:rgb(255,0,0); font-family:Arial; font-size:18px; line-height:26px; text-align:left">转载请注明出处：<a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40019829" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40021651" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40027109" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/45281449" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/45281449</a></span></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div><br><br></div>

<p>好久没有写来CSDN写博客了，前段时间一直在加班赶项目，所以博客一直没有更新；现在空闲时间比较多，所以后面会长期更新博客。</p>
<p>今天来复习一下单元测试基于Junit工具的使用。Junit3.8与Junit4.x的使用还是有些区别的，所以分开来讲，但不管怎样，单元测试的目的并不是证明你是对的，而是为了证明你没有错误，同时也为提高程序健壮性、可重用测试、降低代码后期维护等提供了很好的支持和帮助。</p>
<h3 id="一-基于Junit3-8的实例说明"><a href="#一-基于Junit3-8的实例说明" class="headerlink" title="(一) 基于Junit3.8的实例说明"></a>(一) 基于Junit3.8的实例说明</h3><pre code_snippet_id="653176" snippet_file_name="blog_20150426_1_7396532" name="code" class="java">/**
 * 基本四则运算 -- 目标类
 * 
 * @author [*昨日重现*] lhy_ycu@163.com
 * @since version 1.0
 * @datetime 2015年4月24日 上午10:35:13
 */
public class Calculator {

    private int add(int num1, int num2) {
        return num1 + num2;
    }

    public int subtract(int num1, int num2) {
        return num1 - num2;
    }

    public int multiply(int num1, int num2) {
        return num1 * num2;
    }

    public int divide(int num1, int num2) {
        if (num2 == 0) {
            throw new ArithmeticException(&quot;除数不能为0&quot;);
        }
        return num1 / num2;
    }

}</pre>

<p>基于Junit3.8的测试类</p>
<pre code_snippet_id="653176" snippet_file_name="blog_20150426_2_3412246" name="code" class="java">/**
 * 基于Junit3.8
 * 
 * 测试源代码中的目标类，测试类必须继承TestCase
 * 
 * @author [*昨日重现*] lhy_ycu@163.com
 * @since version 1.0
 * @datetime 2015年4月24日 上午10:43:22
 */
public class CalculatorTest extends TestCase {
    private Calculator cal = null;

    @Override
    protected void setUp() throws Exception {
        // TODO Auto-generated method stub
        super.setUp();
        // 每个测试方法执行前，重新new一个对象，避免测试用例之间的依赖
        cal = new Calculator();
        System.out.println(&quot;在每个测试方法执行前执行--setUp...&quot;);
    }

    /**
     * 测试源代码的私有方法
     */
    public void testAdd() {
        System.out.println(&quot;测试方法testAdd...&quot;);
        // Assert.assertEquals(3, cal.add(1, 2));// blue bar
        try {
            // 1、getClass；2、Class.forName(); 3、.class
            Class&lt;Calculator&gt; calzz = Calculator.class;
            // Class&lt;?&gt; calzz = Class.forName(&quot;com.leo.junit.Calculator&quot;);
            // Calculator cal = calzz.newInstance();
            Method method = calzz.getDeclaredMethod(&quot;add&quot;, new Class[] {
                    Integer.TYPE, Integer.TYPE });// 后两个参数为：方法名、参数类型
            method.setAccessible(true);// 设置为可访问私有的add方法
            // 后两个参数为：目标类对象、实参对象；返回目标方法的结果
            Object obj = method.invoke(cal, new Object[] { 1, 2 });
            Assert.assertEquals(3, obj);
        } catch (Exception e) {
            // e.printStackTrace();
            Assert.fail();
        }

    }

    public void testSubstrub() {
        System.out.println(&quot;测试方法testSubstrub...&quot;);
        Assert.assertEquals(3, cal.subtract(1, 2));// red bar,failure 说明测试没有通过(失败)
    }

    public void testMultiply() {
        System.out.println(&quot;测试方法testMultiply...&quot;);
        Assert.assertEquals(2, cal.multiply(1, 2));// blue bar
    }

    public void testDivide() {
        System.out.println(&quot;测试方法testDivide...&quot;);
        Assert.assertEquals(2, cal.divide(1, 0));// red bar, error 说明测试程序本身出错
    }

    @Override
    protected void tearDown() throws Exception {
        // TODO Auto-generated method stub
        super.tearDown();
        // cal = null;// 在每个测试方法执行后主动销毁对象
        System.out.println(&quot;在每个测试方法执行后执行--tearDown...\n&quot;);
    }

    // public static void main(String[] args) {
    // junit.textui.TestRunner.run(CalculatorTest.class);// 控制台打印错误日志
    // }
}
</pre>

<p><img src="http://img.blog.csdn.net/20150426015838677?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>注意事项：</p>
<p>1）Junit的原则：keep the bar green to keep the code clean。2）测试类与(源代码)目标类的包名尽量要一致，最终它们都会被编译到同一个目录下面，这样就不用导入源代码所在的包。</p>
<p>3) 测试类的命名规则：测试类类名 = 目标类类名前或后加Test; 注意要统一。</p>
<p>4) 测试类必须继承TestCase; 测试用例(方法/类)与测试用例之间一定是完全独立的，不允许出现任何的依赖关系。同时也不能依赖测试方法的执行顺序，也就是删除或注释掉某个测试方法后，其他的测试方法依然能够执行。</p>
<p>5) 测试源代码的私有方法可以采取两种方式：1、修改目标方法的访问修饰符(将private修改为public，一般不推荐);2、使用反射在测试类中调用目标类的私有方法。</p>
<h3 id="二-基于Junit4-x的实例说明"><a href="#二-基于Junit4-x的实例说明" class="headerlink" title="(二)基于Junit4.x的实例说明"></a>(二)基于Junit4.x的实例说明</h3><pre code_snippet_id="653176" snippet_file_name="blog_20150426_3_933609" name="code" class="java">/**
 * 基于Junit4.X --主要基于注解Annotation
 * 
 * @author [*昨日重现*] lhy_ycu@163.com
 * @since version 1.0
 * @datetime 2015年4月25日 上午12:06:52
 */

// @Ignore 将忽略掉该类的所有测试方法
public class CalculatorTest2 {
    private Calculator cal = null;

    @BeforeClass
    public static void beforeClass() {
        System.out.println(&quot;=========在所有测试方法执行前执行--beforeClass=====\n&quot;);
    }

    /**
     * 在测试方法执行完前执行
     */
    @Before
    public void beforeMethod() {
        System.out.println(&quot;在每个测试方法执行前执行--beforeMethod...&quot;);
        cal = new Calculator();
    }

    // 若超时1s，将报error错误
    @Test(timeout = 1000)
    // 若期待有异常抛出：expected = Exception.class
    public void testSubstrub() // throws Exception
    {
        System.out.println(&quot;测试方法testSubstrub被执行...&quot;);
        Assert.assertEquals(-1, cal.subtract(1, 2));
        // Assert.assertEquals(-1, cal.divide(1, 0));
    }

    @Test
    @Ignore(&quot;该testMultiply测试方法由于XX原因需要被忽略掉&quot;)
    public void testMultiply() {
        System.out.println(&quot;测试方法testMultiply被执行...&quot;);
        Assert.assertEquals(2, cal.multiply(1, 2));
    }

    /**
     * assertThat及Hamcrest的基本使用
     */
    @Test
    public void testOther() {
        int result = cal.subtract(1, 2);
        // 关于字符串
        String s1 = &quot;leo&quot;;
        org.junit.Assert.assertThat(result, Matchers.is(-1));
        org.junit.Assert.assertThat(s1, Matchers.not(&quot;llleo&quot;));
        // org.junit.Assert.assertThat(s1, Matchers.equalToIgnoringCase(&quot;LeO&quot;));
        // org.junit.Assert.assertThat(s1,
        // Matchers.equalToIgnoringWhiteSpace(&quot;  Leo &quot;));
        // org.junit.Assert.assertThat(s1, Matchers.containsString(&quot;leo&quot;));
        // org.junit.Assert.assertThat(s1, Matchers.startsWith(&quot;le&quot;));
        // org.junit.Assert.assertThat(s1, Matchers.endsWith(&quot;o&quot;));
        // org.junit.Assert.assertThat(s1, Matchers.equalTo(&quot;leo&quot;));

        // 关于基本类型
        double d1 = 3.1;
        // 在3.0&#177;0.2之间
        org.junit.Assert.assertThat(d1, Matchers.closeTo(3.0, 0.2));
        // 大于3.0
        org.junit.Assert.assertThat(d1, Matchers.greaterThan(3.0));
        // 小于4.0
        org.junit.Assert.assertThat(d1, Matchers.lessThan(4.0));
        // 大于或等于3.0
        org.junit.Assert.assertThat(d1, Matchers.greaterThanOrEqualTo(3.0));
        // 小于或等于4.0
        org.junit.Assert.assertThat(d1, Matchers.lessThanOrEqualTo(4.0));

        // 关于集合
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        map.put(&quot;k1&quot;, &quot;zhangsan&quot;);
        map.put(&quot;k2&quot;, &quot;lisi&quot;);
        // 是否含有该k1=zhangsan的键值对
        org.junit.Assert.assertThat(map, Matchers.hasEntry(&quot;k1&quot;, &quot;zhangsan&quot;));
        // 是否含有键为k2的Item
        org.junit.Assert.assertThat(map, Matchers.hasKey(&quot;k2&quot;));
        // 是否含有值为lisi的Item
        org.junit.Assert.assertThat(map, Matchers.hasValue(&quot;lisi&quot;));
    }

    /**
     * 在测试方法执行完后执行
     */
    @After
    public void afterMethod() {
        // cal = null;// 在每个测试方法执行后主动销毁对象
        System.out.println(&quot;在每个测试方法执行后执行--afterMethod...\n&quot;);
    }

    @AfterClass
    public static void afterClass() {
        System.out.println(&quot;=========在所有测试方法执行后执行--afterClass=====&quot;);
    }
}
</pre>

<p>注意事项：</p>
<p>1）在一个测试类中，所有被@Test注解所修饰的public void方法都是测试用例，可以被JUnit所执行。</p>
<p>2) failure是指测试失败，而error是指测试程序本身出错。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><p>明天开始续《<a href="http://blog.csdn.net/lhy_ycu/article/details/11935087" target="_blank" rel="external">Java学习系列</a>》，包括反射、注解、内部类等等。</p>
<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2015/4/26 2:14:10 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/45281449)
&lt;/div&gt;
&lt;div&gt;
阅读：2631 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/45281449#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2015/04/26/原-基于Junit3-8和Junit4-x的单元测试详解/" data-id="cj8ynscsy000qo49zgd7sbyk1" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2015/04/26/原-基于Junit3-8和Junit4-x的单元测试详解/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-Java设计模式博客全目录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/13/原-Java设计模式博客全目录/" class="article-date">
  <time datetime="2014-10-12T18:04:52.000Z" itemprop="datePublished">2014-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/13/原-Java设计模式博客全目录/">[原]Java设计模式博客全目录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="font-size:14px"><span style="color:rgb(255,0,0); font-family:Arial; font-size:18px; line-height:26px; text-align:left"><strong>转载请注明出处：<a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40019829" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40021651" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40027109" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40028509" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40031567" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/40031567</a></strong></span></span></p>
<p></p>
<p><span style="font-size:14px"></span></p>
<p></p>
<p><span style="font-size:14px">今天来对这23种设计模式做个总结。咱使用设计模式的目的是为了可重用代码、让代码更容易被他人理解、保证代码可靠性，当然设计模式并不是万能的，项目中的实际问题还有具体分析。咱不能为了使用设计模式而使用，而是在分析问题的过程中，想到使用某种设计模式能达到咱需要的效果，而且比不使用设计模式更有优势，那么咱该考虑使用设计模式了。</span></p>
<p><span style="font-size:14px"></span></p>
<p></p>
<h1 id="一、设计模式的一般分类"><a href="#一、设计模式的一般分类" class="headerlink" title="一、设计模式的一般分类"></a><span style="color:rgb(255,0,0)"><span style="font-size:18px">一、设计模式的一般分类</span></span></h1><p><span style="font-size:14px">创建型(Creator)模式（共5种）：单例、原型、建造者、工厂方法、抽象工厂。</span></p>
<p><span style="font-size:14px">结构型(Structure)模式（共7种）：适配器、代理、外观、桥接、组合、享元、装饰者。</span></p>
<p><span style="font-size:14px">行为型(Behavior)模式（共11种）：策略、观察者、模板方法、迭代器、责任链、命令、备忘录、状态、访问者、中介者、解释器。</span></p>
<p><span style="font-size:14px"></span></p>
<p></p>
<h1 id="二、下面谈谈我对这23种设计模式的理解"><a href="#二、下面谈谈我对这23种设计模式的理解" class="headerlink" title="二、下面谈谈我对这23种设计模式的理解"></a><span style="color:rgb(255,0,0)"><span style="font-size:18px">二、下面谈谈我对这23种设计模式的理解</span></span></h1><p><span style="font-size:14px"><strong>1、</strong><span style="font-size:14px"><span style="font-size:14px"><strong>创建型(Creator)模式（共5种）</strong></span></span></span></p>
<p><span style="font-size:14px">①单例（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。实现方式主要有饿汉式和懒汉式两种。</span></p>
<p><span style="font-size:14px">②<span style="font-size:14px">原型(Prototype)：该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类&#20284;的新对象。实现方式主要有浅复制和深复制两种。浅复制的关键是super.clone()；而深复制，需要采用二进制流的形式写入当前对象，再对其进行读取。</span></span></p>
<p><span style="font-size:14px"><span style="font-size:14px">③建造者(Builder)：该模式是将各种产品集中起来进行管理。将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。它关注的是创建复合对象，多个部分。</span></span></p>
<p><span style="font-size:14px">④工厂方法(Factory method)：调用工厂里的方法来生产对象(产品)的。它有3种实现方式：1)普通工厂模式：就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建)。2)多个工厂方法模式：是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。3)静态工厂方法模式：将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。如果你想使用工厂方法模式可以优先选择：静态工厂方法模式。</span></p>
<p><span style="font-size:14px">⑤抽象工厂(Abstract factory)：顾名思义，就是把工厂抽象出来，不同的工厂生产不同的产品。</span></p>
<p><span style="font-size:14px"></span></p>
<p></p>
<p><span style="font-size:14px"><strong>2、<span style="font-size:14px">结构型(Structure)模式（共7种）</span></strong></span></p>
<p><span style="font-size:14px"><span style="font-size:14px">①适配器(Adapter)：将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。1)类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。2)对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Adapter类，持有原类的一个实例，在Adapter类的方法中，调用实例的方法就行。3)接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter实现所有方法，我们写别的类的时候，继承抽象类即可。</span></span></p>
<p><span style="font-size:14px">②代理(Proxy)：代理模式其实就是多一个代理类出来，替原对象进行一些操作。比如咱有的时候打官司需要请律师，因为律师在法律方面有专长，可以替咱进行操作表达咱的想法，这就是代理的意思。有两种实现方式：静态代理(不使用JDK里面的方法)、动态代理(InvocationHandler和Proxy)。</span></p>
<p><span style="font-size:14px">③外观(Facade)：也称门面模式。外观模式是为了解决类与类之间的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。</span></p>
<p><span style="font-size:14px">④桥接(Bridge)： 把事物和其具体实现分开(抽象化与实现化解耦)，使他们可以各自独立的变化。桥接模式其实就是一种将N*M转化成N&#43;M组合的思想。</span></p>
<p><span style="font-size:14px">⑤组合(Composite)：组合模式有时又叫部分-整体模式，将对象组合成树形结构来表示“部分-整体”层次结构。</span></p>
<p><span style="font-size:14px">⑥享元(Flyweight）：运用共享的技术有效地支持大量细粒度的对象。主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销。在某种程度上，你可以把单例看成是享元的一种特例。</span></p>
<p><span style="font-size:14px">⑦<span style="font-size:14px">装饰者(Decorator)：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更具有弹性的替代方案。保持接口，增强性能。</span></span></p>
<p><span style="font-size:14px"><span style="font-size:14px"></span></span></p>
<p></p>
<p><span style="font-size:14px"><span style="font-size:14px"><strong>行为型(Behavior)模式（共11种）</strong></span></span></p>
<p></p>
<p><span style="font-size:14px"><span style="font-size:14px">①策略(Strategy)让用户可以选择执行一个动作的方法，也就是说，用户可以选择不同的策略来进行操作。个人觉得策略模式可以用这个公式：不同的XXX 拥有不同的XXX供用户选择。比如说：不同的象棋棋子拥有不同的走法供用户选择。</span></span></p>
<p><span style="font-size:14px">②观察者(Observer)：在对象之间定义了一对多的依赖关系，这样一来，当一个对象改变状态时，依赖它的对象都会收到通知并自动跟新。Java已经提供了对观察者Observer模式的默认实现，Java对观察者模式的支持主要体现在Observable类和Observer接口。</span></p>
<p><span style="font-size:14px">③模板方法(Template method)：在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以再不改变算法结构的情况下，重新定义算法中的某些步骤。简而言之：模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</span></p>
<p><span style="font-size:14px">④迭代器(Iterator)：提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</span></p>
<p><span style="font-size:14px">⑤责任链(ChainOfResponsibility)： 有多个对象，每个对象持有下一个对象的引用，形成一条链，请求在这条链上传递，直到某一对象决定处理该请求，但是发出者并不清楚最终哪个对象会处理该请求。</span></p>
<p><span style="font-size:14px">⑥命令(Command)：将“请求”(命令/口令)封装成一个对象，以便使用不同的请求、队列或者日志来参数化其对象。命令模式也支持撤销操作。</span></p>
<p><span style="font-size:14px">⑦备忘录(Memento)： 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象。</span></p>
<p><span style="font-size:14px">⑧状态(State)：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。状态模式说白了就是一个对像有不同的状态，不同的状态对应不同的行为，它其实是对switch case这样的语句的拓展。</span></p>
<p><span style="font-size:14px"><span style="font-size:14px"><span style="font-size:14px">⑨</span>解释器(Interpreter)：它定义了对象与对象之间进行某种操作之后会得到什么&#20540;。一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</span></span></p>
<p></p>
<p><span style="font-size:14px">⑩中介者(Mediator)：主要用来降低类与类之间的耦合的，因为如果类与类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。</span></p>
<p><span style="font-size:14px"><span style="font-size:14px"><span style="font-size:14px">⑪</span>访问者</span><span style="font-size:14px">(Visitor)：把<a href="http://blog.csdn.net/lhy_ycu/article/details/9374819" target="_blank" rel="external"><strong>数据结构</strong></a>和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定而算法又容易变化的系统。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者；而它的缺点就是增加新的数据结构很困难。</span></span></p>
<p></p>
<p><span style="font-size:14px"><span style="font-size:14px"></span></span></p>
<p></p>
<h1 id="三、Java设计模式菜鸟系列目录"><a href="#三、Java设计模式菜鸟系列目录" class="headerlink" title="三、Java设计模式菜鸟系列目录"></a><strong><span style="font-size:18px; color:#ff0000">三、Java设计模式菜鸟系列目录</span></strong></h1><div><br><br><span style="font-size:18px"><a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external">Java设计模式菜鸟系列(一)策略模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external">Java设计模式菜鸟系列(二)观察者模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external">Java设计模式菜鸟系列(三)装饰者模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39760895" target="_blank" rel="external">Java设计模式菜鸟系列(四)工厂方法模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external">Java设计模式菜鸟系列(五)抽象工厂模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39785513" target="_blank" rel="external">Java设计模式菜鸟系列(六)单例模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external">Java设计模式菜鸟系列(七)命令模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external">Java设计模式菜鸟系列(八)适配器模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external">Java设计模式菜鸟系列(九)外观模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external">Java设计模式菜鸟系列(十)模板方法模式建模与实现</a></span><br><br><span style="font-size:18px"><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39807741" target="_blank" rel="external">Java设计模式菜鸟系列(十一)迭代器模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external">Java设计模式菜鸟系列(十二)组合模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39829859" target="_blank" rel="external">Java设计模式菜鸟系列(十三)状态模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external">Java设计模式菜鸟系列(十四)代理模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external">Java设计模式菜鸟系列(十五)建造者模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external">Java设计模式菜鸟系列(十六)原型模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external">Java设计模式菜鸟系列(十七)桥接模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external">Java设计模式菜鸟系列(十八)责任链模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external">Java设计模式菜鸟系列(十九)备忘录模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/40019829" target="_blank" rel="external">Java设计模式菜鸟系列(二十)解释器模式建模与实现</a></span><br><br><span style="font-size:18px"><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/40021651" target="_blank" rel="external">Java设计模式菜鸟系列(二十一)享元模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/40027109" target="_blank" rel="external">Java设计模式菜鸟系列(二十二)中介者模式建模与实现</a><br><br><a href="http://blog.csdn.net/lhy_ycu/article/details/40028509" target="_blank" rel="external">Java设计模式菜鸟系列(二十三)访问者模式建模与实现</a></span><br><br><span style="font-size:14px"><br><br></span><br><br><a href="http://download.csdn.net/detail/jave_lover/8714347" target="_blank" rel="external"><strong><span style="font-size:18px">Java设计模式菜鸟系列教程PDF下载地址：http://download.csdn.net/detail/jave_lover/8714347</span></strong></a><br><br></div>

<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2014/10/13 2:04:52 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/40031567)
&lt;/div&gt;
&lt;div&gt;
阅读：4238 评论：4 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/40031567#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2014/10/13/原-Java设计模式博客全目录/" data-id="cj8ynscq2000jo49zj8r0rzao" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2014/10/13/原-Java设计模式博客全目录/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-Java设计模式菜鸟系列-二十三-访问者模式建模与实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/13/原-Java设计模式菜鸟系列-二十三-访问者模式建模与实现/" class="article-date">
  <time datetime="2014-10-12T16:36:28.000Z" itemprop="datePublished">2014-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/13/原-Java设计模式菜鸟系列-二十三-访问者模式建模与实现/">[原]Java设计模式菜鸟系列(二十三)访问者模式建模与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="color:rgb(255,0,0); font-size:18px"><strong>转载请注明出处：<a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40019829" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40021651" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40027109" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40028509" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/40028509</a></strong></span></p>
<p><span style="font-size:18px; color:rgb(255,0,0)"></span></p>
<p></p>
<p><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span></p>
<p>访问者模式(Visitor)：把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定而算法又容易变化的系统。访问者模式的优点是增加操作很容易，因为<span style="background-color:rgb(204,204,204)">增加操作意味着增加新的访问者</span>；而它的缺点就是增加新的数据结构很困难。</p>
<h2 id="一、uml建模："><a href="#一、uml建模：" class="headerlink" title="一、uml建模："></a>一、uml建模：</h2><p><img src="http://img.blog.csdn.net/20141013003657708?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><pre code_snippet_id="483130" snippet_file_name="blog_20141013_1_8493832" name="code" class="java">/**
 * 访问者模式(Visitor)：把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。
 * 
 * 访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，
 * 
 * 可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。
 */
interface Visitor {
    /**
     * 访问对象
     * 
     * @param subject
     *            待访问的对象
     */
    public void visitor(Subject subject);
}

class MyVisitor implements Visitor {
    @Override
    public void visitor(Subject subject) {
        System.out.println(&quot;MyVisitor 访问的属性值为：&quot; + subject.getField());
    }
}

class OtherVisitor implements Visitor {
    @Override
    public void visitor(Subject subject) {
        System.out.println(&quot;OtherVisitor 访问的属性值为：&quot; + subject.getField());
    }
}

interface Subject {
    /** 接受将要访问它的对象 */
    public void accept(Visitor visitor);

    /** 获取将要被访问的属性 */
    public String getField();
}

class MySubject implements Subject {
    private String name;

    public MySubject(String name) {
        this.name = name;
    }

    /**
     * 这是核心：接收【指定的访问者】来访问咱自身的MySubject类的状态或特征
     */
    @Override
    public void accept(Visitor visitor) {
        visitor.visitor(this);
    }

    @Override
    public String getField() {
        return name;
    }
}

/**
 * 客户端测试类
 * 
 * @author Leo
 */
public class Test {
    public static void main(String[] args) {
        /**
         * 创建待访问的对象
         */
        Subject subject = new MySubject(&quot;张三&quot;);
        /**
         * 接受访问对象：这里只接收MyVisitor访问者对象，不接收OtherVisitor访问者对象
         */
        subject.accept(new MyVisitor());
    }
}</pre>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。</p>
<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2014/10/13 0:36:28 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/40028509)
&lt;/div&gt;
&lt;div&gt;
阅读：2151 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/40028509#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2014/10/13/原-Java设计模式菜鸟系列-二十三-访问者模式建模与实现/" data-id="cj8ynscqb000ko49z0iw82dbk" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2014/10/13/原-Java设计模式菜鸟系列-二十三-访问者模式建模与实现/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-Java设计模式菜鸟系列-二十二-中介者模式建模与实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/13/原-Java设计模式菜鸟系列-二十二-中介者模式建模与实现/" class="article-date">
  <time datetime="2014-10-12T16:02:13.000Z" itemprop="datePublished">2014-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/13/原-Java设计模式菜鸟系列-二十二-中介者模式建模与实现/">[原]Java设计模式菜鸟系列(二十二)中介者模式建模与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="color:rgb(255,0,0); font-size:18px"><strong>转载请注明出处：<a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40019829" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40021651" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40027109" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/40027109</a></strong></span></p>
<p><span style="font-size:18px; color:rgb(255,0,0)"></span></p>
<p></p>
<p><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span></p>
<p>中介者模式(Mediator)：主要用来降低类与类之间的耦合的，因为如果类与类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。</p>
<h2 id="一、uml建模："><a href="#一、uml建模：" class="headerlink" title="一、uml建模："></a>一、uml建模：</h2><p><img src="http://img.blog.csdn.net/20141012233901046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><pre code_snippet_id="483119" snippet_file_name="blog_20141013_1_9948910" name="code" class="java">/**
 * 中介者模式(Mediator)：主要用来降低类与类之间的耦合的，因为如果类与类之间有依赖关系的话，
 * 
 * 不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。
 * 
 * 示例：下面以房屋(出租)中介为例
 */
interface Mediator {
    void createMediator();

    void recommendHouse();
}

/**
 * 咱(User)让中介帮我们推荐房子
 * 
 * 所以咱需要持有一个中介实例
 */
abstract class User {
    private Mediator mediator;

    public User(Mediator mediator) {
        this.mediator = mediator;
    }

    public Mediator getMediator() {
        return mediator;
    }

    public abstract void selectHouse();
}

class ZhangSan extends User {

    public ZhangSan(Mediator mediator) {
        super(mediator);
        // TODO Auto-generated constructor stub
    }

    @Override
    public void selectHouse() {
        System.out.println(&quot;张三在选房子...&quot;);
    }
}

class LiSi extends User {

    public LiSi(Mediator mediator) {
        super(mediator);
        // TODO Auto-generated constructor stub
    }

    @Override
    public void selectHouse() {
        System.out.println(&quot;李四在选房子...&quot;);
    }
}

/**
 * 房屋中介：中介向要找房子的那些人推荐房子，由他们选择自己想要的房子。
 * 
 * 因此中介得持有那些实例，才有可能把房子租出去。
 */
class MyMediator implements Mediator {
    private User zhangsan;
    private User lisi;

    public User getZhangsan() {
        return zhangsan;
    }

    public User getLisi() {
        return lisi;
    }

    @Override
    public void createMediator() {
        zhangsan = new ZhangSan(this);
        lisi = new LiSi(this);
    }

    /**
     * 中介向要找房子的那些人推荐房子，由他们选择自己想要的房子
     */
    @Override
    public void recommendHouse() {
        zhangsan.selectHouse();
        lisi.selectHouse();
    }
}

/**
 * 客户端测试类
 * 
 * @author Leo
 */
public class Test {
    public static void main(String[] args) {
        Mediator mediator = new MyMediator();
        mediator.createMediator();
        mediator.recommendHouse();
    }
}</pre>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>中介者模式只需关心和Mediator类的关系，具体类与类之间的关系及调用交给Mediator就行。</p>
<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2014/10/13 0:02:13 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/40027109)
&lt;/div&gt;
&lt;div&gt;
阅读：1835 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/40027109#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2014/10/13/原-Java设计模式菜鸟系列-二十二-中介者模式建模与实现/" data-id="cj8ynscpw000io49z7kwk9oj5" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2014/10/13/原-Java设计模式菜鸟系列-二十二-中介者模式建模与实现/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-Java设计模式菜鸟系列-二十一-享元模式建模与实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/12/原-Java设计模式菜鸟系列-二十一-享元模式建模与实现/" class="article-date">
  <time datetime="2014-10-12T14:27:53.000Z" itemprop="datePublished">2014-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/12/原-Java设计模式菜鸟系列-二十一-享元模式建模与实现/">[原]Java设计模式菜鸟系列(二十一)享元模式建模与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="color:rgb(255,0,0); font-size:18px"><strong>转载请注明出处：<a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40019829" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40021651" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/40021651</a></strong></span></p>
<p><span style="font-size:18px; color:rgb(255,0,0)"></span></p>
<p></p>
<p><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span></p>
<p>享元模式（Flyweight）：运用共享的技术有效地支持大量细粒度的对象。主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销。在某种程度上，你可以把单例看成是享元的一种特例。</p>
<h2 id="一、uml建模："><a href="#一、uml建模：" class="headerlink" title="一、uml建模："></a>一、uml建模：</h2><p><img src="http://img.blog.csdn.net/20141012222507574?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><p><pre name="code" class="java">/**</pre></p>
<ul>
<li>享元模式(Flyweight)：运用共享的技术有效地支持大量细粒度的对象。</li>
<li></li>
<li>主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销。<br>*/<br>abstract class FlyWeight {<br> public abstract void method();<br>}</li>
</ul>
<p>/**</p>
<ul>
<li><p>创建持有key的子类<br>*/<br>class SubFlyWeight extends FlyWeight {<br> private String key;</p>
<p> public SubFlyWeight(String key) {</p>
<pre><code>this.key = key;
</code></pre><p> }</p>
<p> @Override<br> public void method() {</p>
<pre><code>System.out.println(&amp;quot;this is the sub method，and the key is &amp;quot; + this.key);
</code></pre><p> }<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>享元工厂：负责创建和管理享元对象<br>*/<br>class FlyweightFactory {<br> private Map&lt;String, FlyWeight&gt; map = new HashMap&lt;String, FlyWeight&gt;();</p>
<p> /**</p>
<ul>
<li><p>获取享元对象<br>*/<br>public FlyWeight getFlyWeight(String key) {<br> FlyWeight flyWeight = map.get(key);<br> if (flyWeight == null) {</p>
<pre><code>flyWeight = new SubFlyWeight(key);
map.put(key, flyWeight);
</code></pre><p> }<br> return flyWeight;<br>}</p>
<p>/**</p>
</li>
<li>获取享元对象数量<br>*/<br>public int getCount() {<br> return map.size();<br>}<br>}</li>
</ul>
</li>
</ul>
<p>/**</p>
<ul>
<li>客户端测试类</li>
<li></li>
<li><p>@author Leo<br>*/<br>public class Test {<br> public static void main(String[] args) {</p>
<pre><code>/**
 * 创建享元工厂
 */
FlyweightFactory factory = new FlyweightFactory();
/***** 第一种情况：key相同时 ***************/
FlyWeight flyWeightA = factory.getFlyWeight(&amp;quot;aaa&amp;quot;);
FlyWeight flyWeightB = factory.getFlyWeight(&amp;quot;aaa&amp;quot;);
/**
 * 透过打印结果为true可以知道： 由于key都为&amp;quot;aaa&amp;quot;，所以flyWeightA和flyWeightB指向同一块内存地址
 */
System.out.println(flyWeightA == flyWeightB);
flyWeightA.method();
flyWeightB.method();
/**
 * 享元对象数量：1
 */
System.out.println(factory.getCount());

/***** 第二种情况：key不相同时 ***************/
System.out.println(&amp;quot;\n======================================&amp;quot;);
FlyWeight flyWeightC = factory.getFlyWeight(&amp;quot;ccc&amp;quot;);
/**
 * 打印结果为false
 */
System.out.println(flyWeightA == flyWeightC);
flyWeightC.method();
/**
 * 享元对象数量：2
 */
System.out.println(factory.getCount());
</code></pre><p> }<br>}打印结果：</p>
</li>
</ul>
<p>true</p>
<p>this is the sub method，and the key is aaa</p>
<p>this is the sub method，and the key is aaa</p>
<p>1</p>
<p>======================================</p>
<p>false</p>
<p>this is the sub method，and the key is ccc</p>
<p>2</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>享元与单例的区别：1、与单例模式不同，享元模式是一个类可以有很多对象(共享一组对象集合)，而单例是一个类仅一个对象；2、它们的目的也不一样，享元模式是为了节约内存空间，提升程序性能(避免大量的new操作)，而单例模式则主要是共享单个对象的状态及特征。</p>
<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2014/10/12 22:27:53 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/40021651)
&lt;/div&gt;
&lt;div&gt;
阅读：1779 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/40021651#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-二十一-享元模式建模与实现/" data-id="cj8ynscpg000fo49z5xv6ew31" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-二十一-享元模式建模与实现/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-Java设计模式菜鸟系列-二十-解释器模式建模与实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/12/原-Java设计模式菜鸟系列-二十-解释器模式建模与实现/" class="article-date">
  <time datetime="2014-10-12T09:17:29.000Z" itemprop="datePublished">2014-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/12/原-Java设计模式菜鸟系列-二十-解释器模式建模与实现/">[原]Java设计模式菜鸟系列(二十)解释器模式建模与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="color:rgb(255,0,0); font-size:18px"><strong>转载请注明出处：<a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40019829" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/40019829</a></strong></span></p>
<p><span style="font-size:18px; color:rgb(255,0,0)"></span></p>
<p></p>
<p><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span></p>
<p>解释器模式(Interpreter)：它定义了对象与对象之间进行某种操作之后会得到什么&#20540;。一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</p>
<h2 id="一、uml建模："><a href="#一、uml建模：" class="headerlink" title="一、uml建模："></a>一、uml建模：</h2><p><img src="http://img.blog.csdn.net/20141012171610623?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><pre name="code" class="java">/**
 * 解释器模式(Interpreter)：它定义了对象与对象之间进行某种操作之后会得到什么值。
 * 
 * 一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。
 * 
 * 示例：先定义一个实体类，封装两个变量num1、num2
 */
class Entity {
    private double num1;
    private double num2;

    public Entity(double num1, double num2) {
        this.num1 = num1;
        this.num2 = num2;
    }

    public double getNum1() {
        return num1;
    }

    public void setNum1(double num1) {
        this.num1 = num1;
    }

    public double getNum2() {
        return num2;
    }

    public void setNum2(double num2) {
        this.num2 = num2;
    }
}

/**
 * 运算接口
 */
interface Operatable {
    public double interpreter(Entity entity);
}

/**
 * 加法运算
 */
class AddOperation implements Operatable {

    @Override
    public double interpreter(Entity entity) {
        return entity.getNum1() + entity.getNum2();
    }
}

/**
 * 减法运算
 */
class MinusOperation implements Operatable {

    @Override
    public double interpreter(Entity entity) {
        return entity.getNum1() - entity.getNum2();
    }
}

/**
 * 客户端测试类
 * 
 * @author Leo
 */
public class Test {
    public static void main(String[] args) {
        /**
         * 创建加法、减法运算
         */
        AddOperation addOperation = new AddOperation();
        MinusOperation minusOperation = new MinusOperation();
        /**
         * 一、分步运算
         */
        double addResult = addOperation.interpreter(new Entity(20, 30));
        double minusResult = minusOperation.interpreter(new Entity(20, 30));
        System.out.println(&quot;addResult = &quot; + addResult);
        System.out.println(&quot;minusResult = &quot; + minusResult);
        /**
         * 二、混合运算
         */
        double mixResult = new AddOperation().interpreter(new Entity(
                addOperation.interpreter(new Entity(20, 30)), minusOperation
                        .interpreter(new Entity(40, 50))));
        System.out.println(&quot;mixResult = &quot; + mixResult);
    }
}</pre>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>解释器模式用来做各种各样的解释器，如正则表达式的解释器等等。</p>
<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2014/10/12 17:17:29 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/40019829)
&lt;/div&gt;
&lt;div&gt;
阅读：1688 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/40019829#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-二十-解释器模式建模与实现/" data-id="cj8ynscpo000ho49zbsiw0hnv" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-二十-解释器模式建模与实现/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-Java设计模式菜鸟系列-十九-备忘录模式建模与实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/12/原-Java设计模式菜鸟系列-十九-备忘录模式建模与实现/" class="article-date">
  <time datetime="2014-10-12T08:21:25.000Z" itemprop="datePublished">2014-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/12/原-Java设计模式菜鸟系列-十九-备忘录模式建模与实现/">[原]Java设计模式菜鸟系列(十九)备忘录模式建模与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="color:rgb(255,0,0); font-size:18px"><strong>转载请注明出处：<a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/40018967</a></strong></span></p>
<p><span style="font-size:18px; color:rgb(255,0,0)"></span></p>
<p></p>
<p><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span></p>
<p>备忘录模式(Memento)： 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象。</p>
<h2 id="一、uml建模："><a href="#一、uml建模：" class="headerlink" title="一、uml建模："></a>一、uml建模：</h2><p><img src="http://img.blog.csdn.net/20141012161705640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><pre name="code" class="java">/**
 * 备忘录模式(Memento)：主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象
 * 
 * 示例：原始类--&gt; 创建、恢复备忘录
 */
class Original {
    private String state;

    public Original(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    /**
     * 创建备忘录
     */
    public Memento createMemento() {
        return new Memento(state);
    }

    /**
     * 恢复备忘录
     */
    public void recoverMemento(Memento memento) {
        this.state = memento.getState();
    }
}

/**
 * 备忘录
 */
class Memento {
    private String state;

    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}

/**
 * 用来存储备忘录(持有备忘录实例)：只能存储，不能修改
 */
class Storage {
    private Memento memento;

    public Storage(Memento memento) {
        this.memento = memento;
    }

    public Memento getMemento() {
        return memento;
    }
}

/**
 * 客户端测试类
 * 
 * @author Leo
 */
public class Test {
    public static void main(String[] args) {
        /**
         * 创建原始对象
         */
        Original original = new Original(&quot;白天模式&quot;);
        System.out.println(&quot;original初始状态为：&quot; + original.getState());
        /**
         * 创建备忘录
         * 
         * 注意：original.createMemento()会将初始state(白天模式)传给Memento对象
         * 
         * 以备需要的时候可以调用storage.getMemento()来拿到该state(白天模式)状态
         * 
         * 相当于state(白天模式)这个状态已经委托给了storage这个对象来保存
         */
        Storage storage = new Storage(original.createMemento());
        original.setState(&quot;夜间模式&quot;);
        System.out.println(&quot;original修改后的状态为：&quot; + original.getState());
        /**
         * 恢复备忘录
         */
        original.recoverMemento(storage.getMemento());
        System.out.println(&quot;original恢复后的状态为：&quot; + original.getState());
    }
}</pre>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>Memento备忘录设计模式用来备份一个对象的当前状态，当需要的时候，用这个备份来恢复这个对象在某一个时刻的状态。</p>
<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2014/10/12 16:21:25 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/40018967)
&lt;/div&gt;
&lt;div&gt;
阅读：2367 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/40018967#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-十九-备忘录模式建模与实现/" data-id="cj8ynscqx000mo49zi7tf31o9" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-十九-备忘录模式建模与实现/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-Java设计模式菜鸟系列-十八-责任链模式建模与实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/12/原-Java设计模式菜鸟系列-十八-责任链模式建模与实现/" class="article-date">
  <time datetime="2014-10-12T07:16:47.000Z" itemprop="datePublished">2014-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/12/原-Java设计模式菜鸟系列-十八-责任链模式建模与实现/">[原]Java设计模式菜鸟系列(十八)责任链模式建模与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="color:rgb(255,0,0); font-size:18px"><strong>转载请注明出处：<a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/40018231</a></strong></span></p>
<p><span style="font-size:18px; color:rgb(255,0,0)"></span></p>
<p></p>
<p><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span></p>
<p>责任链模式(ChainOfResponsibility)： 有多个对象，每个对象持有下一个对象的引用，形成一条链，请求在这条链上传递，直到某一对象决定处理该请求，但是发出者并不清楚最终哪个对象会处理该请求。</p>
<h2 id="一、uml建模："><a href="#一、uml建模：" class="headerlink" title="一、uml建模："></a>一、uml建模：</h2><p><img src="http://img.blog.csdn.net/20141012151702191?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><pre code_snippet_id="482888" snippet_file_name="blog_20141012_1_8894193" name="code" class="java">/**
 * 责任链模式：有多个对象，每个对象持有下一个对象的引用，形成一条链，
 * 
 * 请求在这条链上传递，直到某一对象决定处理该请求，
 * 
 * 但是发出者并不清楚最终哪个对象会处理该请求。
 */
interface Handler {
    public void operator();
}

/**
 * 这里单独对Handler进行封装，方便修改引用对象
 */
abstract class AbstractHandler implements Handler {
    private Handler handler;

    public Handler getHandler() {
        return handler;
    }

    public void setHandler(Handler handler) {
        this.handler = handler;
    }
}

class MyHandler extends AbstractHandler implements Handler {
    private String name;

    public MyHandler(String name) {
        this.name = name;
    }

    @Override
    public void operator() {
        if (getHandler() != null) {
            System.out.print(name + &quot;，将BUG交给——&gt;&quot;);
            /**
             * 这里是关键。【注意1】这里不是递归哦~
             * 
             * 递归：A(operator)——&gt;A(operator)——&gt;A(operator)
             * 
             * 责任链：A(operator)——&gt;B(operator)——&gt;C(operator)
             */
            getHandler().operator();
        } else {
            System.out.println(name + &quot;处理BUG...\n&quot;);
        }
    }
}

/**
 * 客户端测试类
 * 
 * @author Leo
 */
public class Test {
    public static void main(String[] args) {
        MyHandler handler1 = new MyHandler(&quot;技术总监&quot;);
        MyHandler handler2 = new MyHandler(&quot;项目经理&quot;);
        MyHandler handler3 = new MyHandler(&quot;程序员&quot;);
        /**
         * 如果没有下家，将会自行处理
         * 
         * 打印结果：技术总监处理BUG...
         */
        handler1.operator();
        /**
         * 只要有下家，就传给下家处理
         * 
         * 下面的打印结果：技术总监，将BUG交给——&gt;项目经理，将BUG交给——&gt;程序员处理BUG...
         * 
         * 就这样，原本是技术总监自行处理的BUG，现在一层一层的把责任推给了程序员去处理
         */
        handler1.setHandler(handler2);
        handler2.setHandler(handler3);
        /**
         * 透过打印结果可以知道：MyHandler实例化后将生成一系列相互持有的对象(handler)，构成一条链。
         */
        handler1.operator();
        /**
         * 【注意2】责任链不是链表：链表有个头结点，咱每次必须通过头结点才能访问后面的节点
         * 
         * 而责任链它可以从头访问，也可以从中间开始访问，如：handler2.operator();
         */

    }
}</pre>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>1、责任链模式可以实现，在隐瞒客户端(不知道具体处理的人是谁)的情况下，对系统进行动态的调整。</p>
<p>2、链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。</p>
<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2014/10/12 15:16:47 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/40018231)
&lt;/div&gt;
&lt;div&gt;
阅读：1718 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/40018231#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-十八-责任链模式建模与实现/" data-id="cj8ynscr2000no49zyv5zppov" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-十八-责任链模式建模与实现/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-Java设计模式菜鸟系列-十七-桥接模式建模与实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/12/原-Java设计模式菜鸟系列-十七-桥接模式建模与实现/" class="article-date">
  <time datetime="2014-10-11T17:20:27.000Z" itemprop="datePublished">2014-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/12/原-Java设计模式菜鸟系列-十七-桥接模式建模与实现/">[原]Java设计模式菜鸟系列(十七)桥接模式建模与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="color:rgb(255,0,0); font-size:18px"><strong>转载请注明出处：<a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/40008711</a></strong></span></p>
<p><span style="font-size:18px; color:rgb(255,0,0)"></span></p>
<p></p>
<p><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span></p>
<p>桥接模式(Bridge)： 把事物和其具体实现分开(抽象化与实现化解耦)，使他们可以各自独立的变化。假设你的电脑是双系统(WinXP、Win7)，而且都安装了mysql、oracle、sqlserver、DB2这4种数据库,那么你有2<em>4种选择去连接数据库。按平常的写法，咱要写2</em>4个类，但是使用了桥接模式，你只需写2&#43;4个类,可以看出桥接模式其实就是一种将N*M转化成N&#43;M组合的思想。</p>
<h2 id="一、uml建模："><a href="#一、uml建模：" class="headerlink" title="一、uml建模："></a>一、uml建模：</h2><p><img src="http://img.blog.csdn.net/20141012012037231?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><pre code_snippet_id="482662" snippet_file_name="blog_20141012_1_5743718" name="code" class="java">/**
 * 桥接模式(Bridge)： 把事物和其具体实现分开(抽象化与实现化解耦)，使他们可以各自独立的变化。
 * 
 * 假设你的电脑是双系统(WinXP、Win7)，而且都安装了mysql、oracle、sqlserver、DB2这4种数据库
 * 
 * 那么你有2*4种选择去连接数据库。按平常的写法，咱要写2*4个类，但是使用了桥接模式，你只需写2+4个类
 * 
 * 可以看出桥接模式其实就是一种将N*M转化成N+M组合的思想。
 */
interface Driver {
    public void method();
}

class MysqlDriver implements Driver {

    @Override
    public void method() {
        System.out.println(&quot;use mysql driver to connection db...\n&quot;);
    }
}

class OracleDriver implements Driver {

    @Override
    public void method() {
        System.out.println(&quot;use oracle driver to connection db...\n&quot;);
    }
}

/**
 * 这里你还可以写SqlserverDriver、DB2Driver...
 */

abstract class Computer {
    public abstract void connection(Driver driver);
}

class WinXP extends Computer {
    @Override
    public void connection(Driver driver) {
        System.out.println(&quot;WinXP Computer&quot;);
        driver.method();
    }
}

class Win7 extends Computer {
    @Override
    public void connection(Driver driver) {
        System.out.println(&quot;Win7 Computer&quot;);
        driver.method();
    }
}

/**
 * 客户端测试类
 * 
 * @author Leo
 */
public class Test {
    public static void main(String[] args) {
        /**
         * 第一种组合：winXP使用mysql驱动连接数据库
         */
        Computer winxp = new WinXP();
        winxp.connection(new MysqlDriver());
        /**
         * 第二种组合：win7使用mysql驱动连接数据库
         */
        Computer win7 = new Win7();
        win7.connection(new MysqlDriver());
        /**
         * 第三种组合：winXP使用oracle驱动连接数据库
         */
        Computer cwinxp = new WinXP();
        cwinxp.connection(new OracleDriver());
        /**
         * 第四种组合：winXP使用oracle驱动连接数据库
         */
        Computer cwin7 = new Win7();
        cwin7.connection(new OracleDriver());

    }
}</pre>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>桥接的核心思想是：将抽象化与实现化解耦，使得二者可以独立变化。</p>
<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2014/10/12 1:20:27 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/40008711)
&lt;/div&gt;
&lt;div&gt;
阅读：2143 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/40008711#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-十七-桥接模式建模与实现/" data-id="cj8ynscqr000lo49z0nd86uc0" class="article-share-link">Share</a>
      
        <a href="http://hawkyAndroid.github.io/2014/10/12/原-Java设计模式菜鸟系列-十七-桥接模式建模与实现/#disqus_thread" class="article-comment-link">留言</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">十月 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/04/原-Android学习系列-三-四大组件之Service详解/">[原]Android学习系列(三)四大组件之Service详解</a>
          </li>
        
          <li>
            <a href="/2015/05/26/原-Git学习系列博客全目录/">[原]Git学习系列博客全目录</a>
          </li>
        
          <li>
            <a href="/2015/05/18/原-SQLite应用详解/">[原]SQLite应用详解</a>
          </li>
        
          <li>
            <a href="/2015/05/16/原-全面掌握Mysql知识点及select支持的运算操作/">[原]全面掌握Mysql知识点及select支持的运算操作</a>
          </li>
        
          <li>
            <a href="/2015/05/08/原-Java学习系列博客全目录/">[原]Java学习系列博客全目录</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Hawky<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'jslite';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>