<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android屏幕适配]]></title>
    <url>%2F2018%2F07%2F29%2Fsummary-android-screen-adaptation%2F</url>
    <content type="text"><![CDATA[Res资源下的文件夹说明 anim：存放组件动画文件。 drawable：存放组件属性(含选择器)样式文件、.9图片。 drawable-xxhdpi：存放图片。 mipmap-xxhdpi：存放图标。 raw：原生流(音视频)文件。 Android 屏幕适配方案 适应大部分屏幕时：使用自动生多个屏幕分辨率values-XXXxXXX/dimen配置文件工具。适用范围：边距、字体大小等都用px(像素)。注意：虚拟按键时需要减去虚拟按键高度(略小于差值也可以)。 适应异形、宽屏、平板等小部分屏幕时：需要手动编写多个相应的layout-XXXxXXX/actvity_xxx文件。 横竖屏切换时： ①新建layout-land（横向布局文件夹） 和 layout-port （竖想布局文件夹），然后要在配置Activity的时候进行如下的配置：android:configChanges=”keyboardHidden|orientation” ②不重启Activity：一般需要重写Activity的onConfigurationChanged方法： 12345678910111213@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) &#123; //切换到竖屏 //修改布局文件 setContentView(R.layout.activity_main); &#125; else if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) &#123; //切换到横屏 //修改布局文件 setContentView(R.layout.activity_main); &#125;&#125; ③重启Activity：一般需要重写onSaveInstanceState、onRestoreInstanceState方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import android.content.Context;import android.content.res.Resources;import android.util.DisplayMetrics;import android.util.TypedValue;import android.view.Display;import android.view.WindowManager;import android.widget.LinearLayout;import java.lang.reflect.Method;/** * 像素单位转换工具类 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class DensityUtils &#123; private DensityUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException("cannot be instantiated"); &#125; /** * dp转px */ public static int dp2px(Context context, float dpVal) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpVal, context.getResources().getDisplayMetrics()); &#125; /** * dp转px */ public static int dp2px(float dpVal) &#123; final float scale = Resources.getSystem().getDisplayMetrics().density; return (int) (dpVal * scale + 0.5f); &#125; /** * px转dp */ public static float px2dp(Context context, float pxVal) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (pxVal / scale); &#125; /** * sp转px */ public static int sp2px(Context context, float spVal) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spVal, context.getResources().getDisplayMetrics()); &#125; /** * px转sp */ public static float px2sp(Context context, float pxVal) &#123; return (pxVal / context.getResources().getDisplayMetrics().scaledDensity); &#125; /** * 获取布局参数 */ public static LinearLayout.LayoutParams getLayoutParams(int height) &#123; LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, DensityUtils.dp2px(height)); layoutParams.setMargins(DensityUtils.dp2px(10), DensityUtils.dp2px(10), DensityUtils.dp2px(10), 0); return layoutParams; &#125; /** * 获取屏幕原始尺寸高度（含虚拟功能键高度） */ public static int getTotalHeight(Context context) &#123; WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); Display display = windowManager.getDefaultDisplay(); DisplayMetrics displayMetrics = new DisplayMetrics(); try &#123; Class c = Class.forName("android.view.Display"); @SuppressWarnings("unchecked") Method method = c.getMethod("getRealMetrics", DisplayMetrics.class); method.invoke(display, displayMetrics); return displayMetrics.heightPixels; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0; &#125; /** * 获取屏幕内容高度(不含虚拟按键) */ public static int getScreenHeight(Context context) &#123; WindowManager wm = (WindowManager) context .getSystemService(Context.WINDOW_SERVICE); DisplayMetrics outMetrics = new DisplayMetrics(); wm.getDefaultDisplay().getMetrics(outMetrics); return outMetrics.heightPixels; &#125;&#125; 附上像素文件生成工具(来源网络)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.PrintWriter;/** * values-XXXxXXX/dimens.xml 像素文件生成工具 */public class GenerateValueFiles &#123; private int baseW; private int baseH; private String dirStr = "./res"; private final static String WTemplate = " &lt;dimen name=\"x&#123;0&#125;\"&gt;&#123;1&#125;px&lt;/dimen&gt;\n"; private final static String HTemplate = " &lt;dimen name=\"y&#123;0&#125;\"&gt;&#123;1&#125;px&lt;/dimen&gt;\n"; /** * &#123;0&#125;-HEIGHT */ private final static String VALUE_TEMPLATE = "values-&#123;0&#125;x&#123;1&#125;"; private static final String SUPPORT_DIMESION = "320,480;480,800;480,854;540,960;600,1024;720,1184;720,1196;720,1280;768,1024;800,1280;1080,1812;1080,1920;1440,2560;"; private String supportStr = SUPPORT_DIMESION; public GenerateValueFiles(int baseX, int baseY, String supportStr) &#123; this.baseW = baseX; this.baseH = baseY; if (!this.supportStr.contains(baseX + "," + baseY)) &#123; this.supportStr += baseX + "," + baseY + ";"; &#125; this.supportStr += validateInput(supportStr); System.out.println(supportStr); File dir = new File(dirStr); if (!dir.exists()) &#123; dir.mkdir(); &#125; System.out.println(dir.getAbsoluteFile()); &#125; /** * @param supportStr * w,h_...w,h; * @return */ private String validateInput(String supportStr) &#123; StringBuffer sb = new StringBuffer(); String[] vals = supportStr.split("_"); int w = -1; int h = -1; String[] wh; for (String val : vals) &#123; try &#123; if (val == null || val.trim().length() == 0) continue; wh = val.split(","); w = Integer.parseInt(wh[0]); h = Integer.parseInt(wh[1]); &#125; catch (Exception e) &#123; System.out.println("skip invalidate params : w,h = " + val); continue; &#125; sb.append(w + "," + h + ";"); &#125; return sb.toString(); &#125; public void generate() &#123; String[] vals = supportStr.split(";"); for (String val : vals) &#123; String[] wh = val.split(","); generateXmlFile(Integer.parseInt(wh[0]), Integer.parseInt(wh[1])); &#125; &#125; private void generateXmlFile(int w, int h) &#123; StringBuffer sbForWidth = new StringBuffer(); sbForWidth.append("&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"); sbForWidth.append("&lt;resources&gt;\n"); float cellw = w * 1.0f / baseW; System.out.println("width : " + w + "," + baseW + "," + cellw); for (int i = 1; i &lt; baseW; i++) &#123; sbForWidth.append(WTemplate.replace("&#123;0&#125;", i + "").replace("&#123;1&#125;", change(cellw * i) + "")); &#125; sbForWidth.append(WTemplate.replace("&#123;0&#125;", baseW + "").replace("&#123;1&#125;", w + "")); sbForWidth.append("&lt;/resources&gt;"); StringBuffer sbForHeight = new StringBuffer(); sbForHeight.append("&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"); sbForHeight.append("&lt;resources&gt;\n"); float cellh = h * 1.0f / baseH; System.out.println("height : " + h + "," + baseH + "," + cellh); for (int i = 1; i &lt; baseH; i++) &#123; sbForHeight.append(HTemplate.replace("&#123;0&#125;", i + "").replace("&#123;1&#125;", change(cellh * i) + "")); &#125; sbForHeight.append(HTemplate.replace("&#123;0&#125;", baseH + "").replace("&#123;1&#125;", h + "")); sbForHeight.append("&lt;/resources&gt;"); File fileDir = new File(dirStr + File.separator + VALUE_TEMPLATE.replace("&#123;0&#125;", h + "")// .replace("&#123;1&#125;", w + "")); fileDir.mkdir(); File layxFile = new File(fileDir.getAbsolutePath(), "lay_x.xml"); File layyFile = new File(fileDir.getAbsolutePath(), "lay_y.xml"); try &#123; PrintWriter pw = new PrintWriter(new FileOutputStream(layxFile)); pw.print(sbForWidth.toString()); pw.close(); pw = new PrintWriter(new FileOutputStream(layyFile)); pw.print(sbForHeight.toString()); pw.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static float change(float a) &#123; int temp = (int) (a * 100); return temp / 100f; &#125; public static void main(String[] args) &#123; int baseW = 320; int baseH = 400; String addition = ""; try &#123; if (args.length &gt;= 3) &#123; baseW = Integer.parseInt(args[0]); baseH = Integer.parseInt(args[1]); addition = args[2]; &#125; else if (args.length &gt;= 2) &#123; baseW = Integer.parseInt(args[0]); baseH = Integer.parseInt(args[1]); &#125; else if (args.length &gt;= 1) &#123; addition = args[0]; &#125; &#125; catch (NumberFormatException e) &#123; System.err.println("right input params : java -jar xxx.jar width height w,h_w,h_..._w,h;"); e.printStackTrace(); System.exit(-1); &#125; new GenerateValueFiles(baseW, baseH, addition).generate(); &#125;&#125;]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的启动模式及其应用场景]]></title>
    <url>%2F2018%2F07%2F19%2Fsummary-activity-launch-mode%2F</url>
    <content type="text"><![CDATA[1. Task任务栈(1)程序打开时就创建了一个任务栈, 用于存储当前程序的activity,所有的activity属于一个任务栈。 (2)一个任务栈包含了一个activity的集合, 去有序的选择哪一个activity和用户进行交互:只有在任务栈栈顶的activity才可以跟用户进行交互。 (3)任务栈可以移动到后台, 并且保留了每一个activity的状态. 并且有序的给用户列出它们的任务, 而且还不丢失它们状态信息。 (4)退出应用程序时：当把所有的任务栈中所有的activity清除出栈时,任务栈会被销毁,程序退出。 2.LaunchMode启动模式启动模式（launchMode）在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。 3 Activity一共有4个启动模式3.1 standardstandard模式是默认的启动模式。不管有没有已存在的实例，都生成新的实例。 3.2 singleTopsingleTop启动模式，如果Activity实例已经位于栈顶，则不再生成新的实例；反则生成新的实例。使用场景：singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面。 3.3 singleTasksingleTask启动模式，发现有对应的Activity实例，则使此Activity实例之上的其它的Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。使用场景：例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 3.4 singleInstancesingleInstance这种启动模式比较特殊，因为它会启用一个新的栈结构，将Activity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。使用场景：singleInstance适合需要与程序分离开的页面。例如闹铃提醒(将闹铃提醒与闹铃设置分离)， 呼叫来电界面等。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP 使用详解]]></title>
    <url>%2F2018%2F06%2F01%2Fsummary-udp-01%2F</url>
    <content type="text"><![CDATA[UDP的使用范例BroadcastData -广播数据包对象1234567891011121314151617181920212223242526272829303132package com.leo.udp;/** * 接收的广播数据包 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class BroadcastData &#123; private PacketRx packetRx; private String ip; private int port; public BroadcastData(PacketRx packetRx, String ip, int port) &#123; this.packetRx = packetRx; this.ip = ip; this.port = port; &#125; public PacketRx getPacketRx() &#123; return packetRx; &#125; public String getIp() &#123; return ip; &#125; public int getPort() &#123; return port; &#125;&#125; BroadcastRunnable -广播发送线程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.leo.udp;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;import java.net.SocketException;/** * UDP广播一直发送：每秒发1次 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class BroadcastRunnable implements Runnable &#123; private static final String TAG = BroadcastRunnable.class.getSimpleName(); private static final String FIXED_BROADCAST_IP = "255.255.255.255"; private static final int FIXED_BROADCAST_PORT = 9002; private static final long FIXED_BROADCAST_PERIOD = 1000L; private DatagramSocket mSocket = null; private volatile boolean stop = false; public BroadcastRunnable() &#123; &#125; /** * 停止广播 */ public void stopBroadcast() &#123; this.stop = true; if (mSocket != null) &#123; try &#123; if (!mSocket.isClosed()) &#123; mSocket.close(); &#125; mSocket.disconnect(); mSocket = null; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; @Override public void run() &#123; System.out.println("-----start BroadcastThread-----"); try &#123; mSocket = new DatagramSocket(); mSocket.setBroadcast(true); byte[] data; // 待发送的数据包、待赋值 DatagramPacket packet = new DatagramPacket(data, data.length, new InetSocketAddress(FIXED_BROADCAST_IP, FIXED_BROADCAST_PORT)); System.out.println("Broadcast Address:" + packet.getSocketAddress()); while (!stop) &#123; mSocket.send(packet); System.out.println("Broadcast data send success &gt;&gt;" + bytesToHexString(data)); Thread.sleep(FIXED_BROADCAST_PERIOD); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; stopBroadcast(); System.out.println("-----end BroadcastThread-----"); &#125;&#125; ReceiveRunnable -广播接收线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.leo.udp;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;/** * 接收UDP数据包 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class ReceiveRunnable implements Runnable &#123; private static final String TAG = ReceiveRunnable.class.getSimpleName(); private static final String FIXED_BROADCAST_IP = "255.255.255.255"; private static final int FIXED_BROADCAST_PORT = 58888; private DatagramSocket mSocket = null; private volatile boolean stop = false; private BroadcastDataListener mOnDataListener; public ReceiveRunnable(BroadcastDataListener listener) &#123; this.mOnDataListener = listener; &#125; /** * 停止广播 */ public void stopBroadcast() &#123; this.stop = true; if (mSocket != null) &#123; try &#123; if (!mSocket.isClosed()) &#123; mSocket.close(); &#125; mSocket.disconnect(); mSocket = null; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; @Override public void run() &#123; System.out.println("-----start ReceiveThread-----"); try &#123; mSocket = new DatagramSocket(new InetSocketAddress(FIXED_BROADCAST_IP, FIXED_BROADCAST_PORT)); mSocket.setBroadcast(true); while (!stop) &#123; byte[] data = new byte[128];// 大小需要结合实际情况来定 DatagramPacket packet = new DatagramPacket(data, data.length); mSocket.receive(packet);// 接收广播数据包 // 这里可将data解析（解密）封装成数据包对象packetRx // ... System.out.println("Socket Address:" + packet.getSocketAddress()); System.out.println("receive broadcast data--&lt;&lt;" + packetRx); if (mOnDataListener != null) &#123; mOnDataListener.onReceiveData(new BroadcastData(packetRx, packet.getAddress().getHostAddress(), packet.getPort())); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; stopBroadcast(); System.out.println("-----end ReceiveThread-----"); &#125;&#125; BroadcastDataListener -广播数据包监听1234567891011package com.leo.udp;/** * 监听广播数据包 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public interface BroadcastDataListener &#123; void onReceiveData(BroadcastData broadcastData);&#125; ThreadPoolManager -线程池管理1234567891011121314151617181920212223242526272829303132package com.leo.tcp;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 线程池管理 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class ThreadPoolManager &#123; private ExecutorService service; private ThreadPoolManager() &#123; // 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 service = Executors.newCachedThreadPool(); &#125; public void execute(Runnable runnable) &#123; service.execute(runnable);// 仍到线程池中 &#125; public static ThreadPoolManager getInstance() &#123; return Holder.INSTANCE; &#125; private static class Holder &#123; private static final ThreadPoolManager INSTANCE = new ThreadPoolManager(); &#125;&#125;]]></content>
      <categories>
        <category>Socket通信</category>
      </categories>
      <tags>
        <tag>Socket通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP 使用详解]]></title>
    <url>%2F2018%2F06%2F01%2Fsummary-tcp-01%2F</url>
    <content type="text"><![CDATA[TCP的使用范例SocketClient -客户端对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.leo.tcp;import java.io.IOException;import java.net.Socket;/** * Socket客户端 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class SocketClient &#123; private Socket socket; private String ip; private int port; public SocketClient(Socket socket, String ip, int port) &#123; this.socket = socket; this.ip = ip; this.port = port; &#125; /** * 发送数据给Socket客户端 * * @param data * 加密后的数据 */ public void sendData(byte[] data) throws IOException &#123; if (socket != null &amp;&amp; data != null) &#123; socket.getOutputStream().write(data); &#125; &#125; /** * 关闭Socket客户端 */ public void close() &#123; if (socket == null) return; try &#123; socket.getInputStream().close(); &#125; catch (IOException e) &#123; // e.printStackTrace(); &#125; try &#123; socket.getOutputStream().close(); &#125; catch (IOException e) &#123; // e.printStackTrace(); &#125; if (this.socket != null) &#123; try &#123; this.socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; this.socket = null; System.out.println(ip + "----Socket client closed----"); &#125; public Socket getSocket() &#123; return socket; &#125; public String getIp() &#123; return ip; &#125; public int getPort() &#123; return port; &#125; @Override public String toString() &#123; return "SocketClient [socket=" + socket + ", ip=" + ip + ", port=" + port + "]"; &#125;&#125; TCPClientRunnable -客户端线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.leo.tcp;import java.io.BufferedInputStream;import java.io.DataInputStream;import java.io.IOException;/** * 单独封装一个线程来处理客户端接收的数据 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class TCPClientRunnable implements Runnable &#123; private static final String TAG = TCPClientRunnable.class.getSimpleName(); private volatile boolean stop = false; private SocketClient mSocketClient;// Socket客户端 public TCPClientRunnable(SocketClient socketClient) &#123; this.mSocketClient = socketClient; &#125; @Override public void run() &#123; System.out.println("-----start TCPClientThread-----"); DataInputStream br = null; System.out.println("Socket client is coming---" + mSocketClient.getIp() + ":" + mSocketClient.getPort()); try &#123; br = new DataInputStream(new BufferedInputStream(mSocketClient.getSocket().getInputStream()));// 读取客户端数据(每次循环读取一条完整的数据指令) while (!stop) &#123; int head = 0xFF &amp; br.readByte();// 没有数据时处于阻塞状态 System.out.println("head:" + head); if (head != 0xFF) continue;// 需要根据协议来定 int length = br.readShort();// 需要根据协议来定，这里写死2字节 System.err.println("length:" + length); byte[] buff = new byte[length];// 总的具体数据大小 int hasRead;// 每次读的数据长度 int totalRead = 0;// 累计读的数据长度 while ((hasRead = br.read(buff, totalRead, length - totalRead)) != -1) &#123;// length - totalRead：剩余数据长度 totalRead += hasRead; if (totalRead &gt;= length) break; &#125; // 下面可以将：head、length、buff（具体消息体）（解密）封装成一个包对象packetRx // ... // 提供回调接口，方便UI更新 for (TCPCallback callback : TCPServerRunnable.sDeviceMessageCallbacks) &#123; callback.onReceiveMessage(mSocketClient, packetRx); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; this.stop = true; if (br != null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; synchronized (TCPServerRunnable.sSocketClients) &#123; TCPServerRunnable.sSocketClients.remove(mSocketClient); System.out.println("The number of Socket client is：" + TCPServerRunnable.sSocketClients.size()); // 客户端数量发生变化 for (TCPCallback callback : TCPServerRunnable.sDeviceMessageCallbacks) &#123; callback.onClientsChanged(TCPServerRunnable.sSocketClients); &#125; &#125; System.out.println("-----end TCPClientThread-----"); &#125;&#125; TCPServerRunnable -服务器线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.leo.tcp;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.Collections;import java.util.HashSet;import java.util.Set;import java.util.concurrent.CopyOnWriteArrayList;/** * TCP服务线程 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class TCPServerRunnable implements Runnable &#123; private static final String TAG = TCPServerRunnable.class.getSimpleName(); /** * Socket客户端集合 */ static Set&lt;SocketClient&gt; sSocketClients = Collections.synchronizedSet(new HashSet&lt;SocketClient&gt;()); /** * 设备数据回调监听（只针对多个界面更新，不针对Socket客户端） */ public static CopyOnWriteArrayList&lt;TCPCallback&gt; sDeviceMessageCallbacks = new CopyOnWriteArrayList&lt;&gt;(); /** * TCP服务 默认端口58888 */ public static final int DEFAULT_TCP_PORT = 58888; /** * TCP端口随机生成 */ private int tcpPort = DEFAULT_TCP_PORT; private volatile boolean stop = true; private ServerSocket mServerSocket = null; public TCPServerRunnable() &#123; &#125; public int getTcpPort() &#123; return tcpPort; &#125; public boolean isStop() &#123; return stop; &#125; @Override public void run() &#123; System.out.println("-----start TCPServerThread-----"); try &#123; mServerSocket = new ServerSocket(0); // 获取随机端口 tcpPort = mServerSocket.getLocalPort(); System.out.println("Socket server waiting connect...tcpPort:" + tcpPort); stop = false; while (!stop) &#123; // 等待连接, 此时线程处于阻塞状态 Socket socket = mServerSocket.accept(); // 60s读取超时 socket.setSoTimeout(60 * 1000); // 这里需要判断：如果来了一个已存在的IP-Socket，则需要断开原来的连接 SocketClient socketClient = findSocketClientByIP(socket.getInetAddress().getHostAddress()); if (socketClient != null) &#123; socketClient.close(); try &#123; Thread.sleep(500L); &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); &#125; &#125; socketClient = new SocketClient(socket, socket.getInetAddress().getHostAddress(), socket.getPort()); synchronized (sSocketClients) &#123; sSocketClients.add(socketClient); System.out.println("The number of Socket client is：" + sSocketClients.size()); // 客户端数量发生变化 for (TCPCallback callback : sDeviceMessageCallbacks) &#123; callback.onClientsChanged(sSocketClients); &#125; &#125; ThreadPoolManager.getInstance().execute(new TCPClientRunnable(socketClient)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; stopTCPServer(); System.out.println("-----end TCPServerThread-----"); &#125; /** * 停止TCP服务 */ public void stopTCPServer() &#123; this.stop = true; if (mServerSocket != null) &#123; try &#123; mServerSocket.close(); closeAllSocketClient(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mServerSocket = null; &#125; &#125; /** * 关闭所有Socket客户端 */ private void closeAllSocketClient() &#123; synchronized (sSocketClients) &#123; for (SocketClient client : sSocketClients) &#123; client.close(); &#125; &#125; &#125; /** * 通过IP获取SocketClient * * @param ip * IP地址 * @return Socket客户端 */ public SocketClient findSocketClientByIP(String ip) &#123; for (SocketClient client : sSocketClients) &#123; if (ip.equals(client.getIp())) &#123; return client; &#125; &#125; return null; &#125; /** * 通过IP向某个客户端发消息 */ public void sendDataByIP(String ip, byte[] data) throws IOException &#123; SocketClient client = findSocketClientByIP(ip); if (client != null) &#123; client.sendData(data); &#125; &#125;&#125; ThreadPoolManager -线程池管理1234567891011121314151617181920212223242526272829303132package com.leo.tcp;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 线程池管理 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class ThreadPoolManager &#123; private ExecutorService service; private ThreadPoolManager() &#123; // 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 service = Executors.newCachedThreadPool(); &#125; public void execute(Runnable runnable) &#123; service.execute(runnable);// 仍到线程池中 &#125; public static ThreadPoolManager getInstance() &#123; return Holder.INSTANCE; &#125; private static class Holder &#123; private static final ThreadPoolManager INSTANCE = new ThreadPoolManager(); &#125;&#125;]]></content>
      <categories>
        <category>Socket通信</category>
      </categories>
      <tags>
        <tag>Socket通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket知识点总结]]></title>
    <url>%2F2018%2F05%2F31%2Fsummary-socket-01%2F</url>
    <content type="text"><![CDATA[计算机网络分层计算机网络分为五层：物理层、数据链路层、网络层、传输层、应用层。其中：网络层：负责根据IP找到目的地址的主机。传输层：通过端口把数据传到目的主机的目的进程，来实现进程与进程之间的通信。 C/S结构定义：即客户端/服务器结构，是软件系统体系结构作用：充分利用两端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。Socket正是使用这种结构建立连接的，一个套接字接客户端，一个套接字接服务器。 Socket的使用类型主要有两种：流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务 TCP协议定义：Transmission Control Protocol，即传输控制协议，是一种传输层通信协议。三次握手的目的是为了防止服务器端因为接收了早已失效的连接请求报文从而一直等待客户端请求，从而浪费资源。 特点：面向连接、面向字节流、全双工通信、可靠.①面向连接：指的是要使用TCP传输数据，必须先建立TCP连接，传输完成后释放连接，就像打电话一样必须先拨号建立一条连接，打完后挂机释放连接。 ②全双工通信：即一旦建立了TCP连接，通信双方可以在任何时候都能发送数据。 ③可靠的：指的是通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。 ④面向字节流：流，指的是流入到进程或从进程流出的字符序列。简单来说，虽然有时候要传输的数据流太大，TCP报文长度有限制，不能一次传输完，要把它分为好几个数据块，但是由于可靠性保证，接收方可以按顺序接收数据块然后重新组成分块之前的数据流，所以TCP看起来就像直接互相传输字节流一样，面向字节流。 UDP协议定义：User Datagram Protocol，即用户数据报协议，是一种传输层通信协议。 特点：无连接的、不可靠的、面向报文、没有拥塞控制.无连接的：和TCP要建立连接不同，UDP传输数据不需要建立连接，就像写信，在信封写上收信人名称、地址就可以交给邮局发送了，至于能不能送到，就要看邮局的送信能力和送信过程的困难程度了。 不可靠的：因为UDP发出去的数据包发出去就不管了，不管它会不会到达，所以很可能会出现丢包现象，使传输的数据出错。 面向报文：数据报文，就相当于一个数据包，应用层交给UDP多大的数据包，UDP就照样发送，不会像TCP那样拆分。 没有拥塞控制：拥塞，是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象，就像交通堵塞一样。TCP建立连接后如果发送的数据因为信道质量的原因不能到达目的地，它会不断重发，有可能导致越来越塞，所以需要一个复杂的原理来控制拥塞。而UDP就没有这个烦恼，发出去就不管了。 UDP协议应用场景很多的实时应用（如IP电话、实时视频会议、某些多人同时在线游戏等）要求源主机以很定的速率发送数据，并且允许在网络发生拥塞时候丢失一些数据，但是要求不能有太大的延时，UDP就刚好适合这种要求。所以说，只有不适合的技术，没有真正没用的技术。 Socket 与 Http 对比 工作性质不同。Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题。而HTTP协议 属于 应用层，解决的是数据如何包装的问题。 工作方式不同。Http：采用 请求-响应 方式即建立网络连接后，当 客户端 向 服务器 发送请求后，服务器端才能向客户端返回数据。可理解为：是客户端有需要才进行通信。而Socket：采用 服务器主动发送数据 的方式即建立网络连接后，服务器可主动发送消息给客户端，而不需要由客户端向服务器发送请求可理解为：是服务器端有需要才进行通信。]]></content>
      <categories>
        <category>Socket通信</category>
      </categories>
      <tags>
        <tag>Socket通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS使用总结]]></title>
    <url>%2F2018%2F05%2F30%2Fsummary-as-develop-2018-5-28%2F</url>
    <content type="text"><![CDATA[android gradle依赖的几种方式implementation使用了该命令编译的依赖，它仅仅对当前的Moudle提供接口。好处： 1. 加快编译速度。2. 隐藏对外不必要的接口。 api跟 2.x 版本的 compile完全相同。与implementation的区别是：implementation内部module使用，而api可对外提供接口。 provided（compileOnly）只在编译时有效，不会参与打包可以在自己的moudle中使用该方式依赖一些比如com.android.support，gson这些使用者常用的库，避免冲突。 apk（runtimeOnly）只在生成apk的时候参与打包，编译时不会参与，很少用。]]></content>
      <categories>
        <category>AS总结</category>
      </categories>
      <tags>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为人处世]]></title>
    <url>%2F2018%2F05%2F27%2Fsummery-do-something-2018-5-27%2F</url>
    <content type="text"><![CDATA[看望病友：安慰、鼓励、善意的“欺骗”。 日常朋友聊天：谦逊、求同存异、“不离间”。 问朋友借东西：用商量的语气、别说气话、礼貌归还。 为朋友劝架：心平气和、用幽默解围、不要有个人情绪。 邻里相处：平等、表扬、切勿探究别人的私事。 对朋友下逐客令：把理由说清楚、商量性的提醒、安排他干点别的事。 在酒桌上说话：话题顾忌他人，尊重宾主、别强求劝酒。 同事之间：巧用称谓搞好关系、不要过分表现自己、建设性口气。 寻找陌生人之间话题：发现共同点、话题符合身份、避免过多使用专业术语、尽量选择众人关心的事件、不要轻易转移话题、虚心请教、换位思考、目的性不要太强。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT协议总结]]></title>
    <url>%2F2018%2F05%2F09%2Fsummary-mqtt-protocol%2F</url>
    <content type="text"><![CDATA[1. MQTT控制报文的格式1.1 MQTT控制报文的结构 MQTT控制报文的结构 Fixed header 固定报头，所有控制报文都包含 Variable header 可变报头，部分控制报文包含 Payload 有效载荷，部分控制报文包含 1.2 固定报头（2个字节） Bit 7 6 5 4 3 2 1 0 byte 1 MQTT控制报文的类型 用于指定控制报文类型的标志位 byte 2 剩余长度 1.2.1 控制报文的类型（14种）–高四位 名字 值 报文流动方向 描述 Reserved 0 禁止 保留 CONNECT 1 客户端到服务端 客户端请求连接服务端 CONNACK 2 服务端到客户端 连接报文确认 PUBLISH 3 两个方向都允许 发布消息 PUBACK 4 两个方向都允许 QoS 1 消息发布收到确认 PUBREC 5 两个方向都允许 发布收到（保证交付第一步） PUBREL 6 两个方向都允许 发布释放（保证交付第二步） PUBCOMP 7 两个方向都允许 QoS 2 消息发布完成（保证交互第三步） SUBSCRIBE 8 客户端到服务端 客户端订阅请求 SUBACK 9 服务端到客户端 订阅请求报文确认 UNSUBSCRIBE 10 客户端到服务端 客户端取消订阅请求 UNSUBACK 11 服务端到客户端 取消订阅报文确认 PINGREQ 12 客户端到服务端 心跳请求 PINGRESP 13 服务端到客户端 心跳响应 DISCONNECT 14 客户端到服务端 客户端断开连接 Reserved 15 禁止 保留 1.2.2 标志位 –低四位 控制报文 固定报头标志 Bit 3 Bit 2 Bit 1 Bit 0 CONNECT Reserved 0 0 0 0 CONNACK Reserved 0 0 0 0 PUBLISH Used in MQTT 3.1.1 DUP 1 QoS 2 QoS 2 RETAIN 3 PUBACK Reserved 0 0 0 0 PUBREC Reserved 0 0 0 0 PUBREL Reserved 0 0 1 0 PUBCOMP Reserved 0 0 0 0 SUBSCRIBE Reserved 0 0 1 0 SUBACK Reserved 0 0 0 0 UNSUBSCRIBE Reserved 0 0 1 0 UNSUBACK Reserved 0 0 0 0 PINGREQ Reserved 0 0 0 0 PINGRESP Reserved 0 0 0 0 DISCONNECT Reserved 0 0 0 0 1.2.3 剩余长度 –从第 2 个字节开始位置剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。 剩余长度字段使用一个变长度编码方案，对小于 128 的值它使用单字节编码。更大的值按下面的方式处理。低 7 位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码 128 个数值和一个 延续位（ continuation bit ） 。剩余长度字段最大 4 个字节。 分别表示（每个字节的低 7 位用于编码数据，最高位是标志位）：1 个字节时，从 0(0x00)到 127(0x7f)2 个字节时，从 128(0x80,0x01)到 16383(0Xff,0x7f)3 个字节时，从 16384(0x80,0x80,0x01)到 2097151(0xFF,0xFF,0x7F)4 个字节时，从 2097152(0x80,0x80,0x80,0x01)到 268435455(0xFF,0xFF,0xFF,0x7F) 1.3 可变报头某些 MQTT 控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。 很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是 PUBLISH（QoS&gt;0 时），PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。 注意：QoS 设置为 0 的 PUBLISH 报文 不能包含报文标识符。PUBACK, PUBREC, PUBREL 报文 必须包含与最初发送的 PUBLISH 报文相同的报文标识符。类似地，SUBACK 和 UNSUBACK 必须包含在对应的 SUBSCRIBE 和 UNSUBSCRIBE 报文中使用的报文标识符。 1.4 有效载荷某些 MQTT 控制报文在报文的最后部分包含一个有效载荷。对于PUBLIC来说，有效载荷就是应用消息。 1.4.1 包含有效载荷的控制报文 控制报文 有效载荷 CONNECT 需要 CONNACK 不需要 PUBLISH 可选 PUBACK 不需要 PUBREC 不需要 PUBREL 不需要 PUBCOMP 不需要 SUBSCRIBE 需要 SUBACK 需要 UNSUBSCRIBE 需要 PINGRESP 不需要 DISCONNECT 不需要 2. MQTT控制报文（14种）2.1 CONNECT – 连接服务端客户端到服务端的网络连接建立后，客户端发送给服务端的第一个报文必须是CONNECT报文。在一个网络连接上，客户端只能发送一次 CONNECT 报文。服务端 必须将客户端发送的第二个 CONNECT报文当作协议违规处理并断开客户端的连接。有效载荷包含一个或多个编码的字段。包括客户端的唯一标识符，Will 主题，Will 消息，用户名和密码。除了客户端标识之外，其它的字段都是可选的，基于标志位来决定可变报头中是否需要包含这些字段。 2.2 CONNACK – 确认连接请求服务端发送 CONNACK 报文响应从客户端收到的 CONNECT 报文。服务端发送给客户端的第一个报文必须须是 CONNACK。如果客户端在合理的时间内没有收到服务端的 CONNACK 报文，客户端 应该关闭网络连接。合理的时间取决于应用的类型和通信基础设施。 连接返回码的值 值 返回码响应 描述 0 0x00 连接已接受 连接已被服务端接受 1 0x01 连接已拒绝，不支持的协议版本 服务端不支持客户端请求的 MQTT 协议级别 2 0x02 连接已拒绝，不合格的客户端标识符 客户端标识符是正确的 UTF-8 编码，但服务端不允许使用 3 0x03 连接已拒绝，服务端不可用 网络连接已建立，但 MQTT 服务不可用 4 0x04 连接已拒绝，无效的用户名或密码 用户名或密码的数据格式无效 5 0x05 连接已拒绝，未授权 客户端未被授权连接到此服务器 6-255 保留 如果认为上表中的所有连接返回码都不太合适，那么服务端 必须关闭网络连接，不需要发送 CONNACK 报文。 2.3 PUBLISH – 发布消息PUBLISH 控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息。 PUBLISH 报文固定报头 Bit 7 6 5 4 3 2 1 0 byte 1 MQTT控制报文的类型 DUP(重发标志) QoS等级 RETAIN byte 2 剩余长度 备注：① 如果 DUP 标志被设置为 0，表示这是客户端或服务端第一次请求发送这个 PUBLISH 报文。如果 DUP 标志被设置为 1，表示这可能是一个早前报文请求的重发。② QoS=0表示最多分发1次、QoS=1表示至少分发一次、QoS=2表示只分发一次。③ 如果客户端发给服务端的 PUBLISH 报文的保留标志位 0，服务端 不能存储这个消息也 不能移除或替换任何现存的保留消息。④ 服务端发送给订阅客户端的 PUBLISH 报文的主题名 必须匹配该订阅的主题过滤器。 2.4 PUBACK – 发布确认PUBACK 报文是对 QoS 1 等级的 PUBLISH 报文的响应。 2.5 PUBREC – 发布收到PUBREC 报文是对 QoS 等级 2 的 PUBLISH 报文的响应。它是 QoS 2 等级协议交换的第二个报文。 2.6 PUBREL – 发布释放PUBREL 报文是对 PUBREC 报文的响应。它是 QoS 2 等级协议交换的第三个报文。 2.7 PUBCOMP – 发布完成PUBCOMP报文是对PUBREL报文的响应。它是QoS 2等级协议交换的第四个也是最后一个报文。 2.8 SUBSCRIBE - 订阅主题客户端向服务端发送 SUBSCRIBE 报文用于创建一个或多个订阅。每个订阅注册客户端关心的一个或多个主题。为了将应用消息转发给与那些订阅匹配的主题，服务端发送 PUBLISH 报文给客户端。SUBSCRIBE报文也（为每个订阅）指定了最大的 QoS 等级，服务端根据这个发送应用消息给客户端。SUBSCRIBE 报文的有效载荷包含了一个主题过滤器列表，它们表示客户端想要订阅的主题。每一个过滤器后面跟着一个字节，这个字节被叫做服务质量要求（Requested QoS）。它给出了服务端向客户端发送应用消息所允许的最大 QoS 等级。SUBSCRIBE 报文的有效载荷 必须包含至少一对主题过滤器 和 QoS 等级字段组合。服务端收到客户端发送的一个 SUBSCRIBE 报文时， 必须使用 SUBACK 报文响应SUBACK 报文 必须和等待确认的 SUBSCRIBE 报文有相同的报文标识符。 2.9 SUBACK – 订阅确认服务端发送 SUBACK 报文给客户端，用于确认它已收到并且正在处理 SUBSCRIBE 报文。SUBACK 报文包含一个返回码清单，它们指定了 SUBSCRIBE 请求的每个订阅被授予的最大 QoS 等级。SUBACK有效载荷包含一个返回码清单。每个返回码对应等待确认的 SUBSCRIBE 报文中的一个主题过滤器。返回码的顺序 必须和 SUBSCRIBE 报文中主题过滤器的顺序相同。 2.10 UNSUBSCRIBE – 取消订阅客户端发送 UNSUBSCRIBE 报文给服务端，用于取消订阅主题。UNSUBSCRIBE 报文固定报头的第 3,2,1,0 位是保留位且 必须分别设置为 0,0,1,0。服务端 必须认为任何其它的值都是不合法的并关闭网络连接。UNSUBSCRIBE 报文的有效载荷 必须至少包含一个消息过滤器。 2.11 UNSUBACK – 取消订阅确认服务端发送 UNSUBACK 报文给客户端用于确认收到 UNSUBSCRIBE 报文。 2.12 12 PINGREQ – 心跳请求客户端发送 PINGREQ 报文给服务端的。用于： 在没有任何其它控制报文从客户端发给服务的时，告知服务端客户端还活着。 请求服务端发送 响应确认它还活着。 使用网络以确认网络连接没有断开。 —注意：保持连接（Keep Alive）处理中用到这个报文 2.13 PINGRESP – 心跳响应服务端发送 PINGRESP 报文响应客户端的 PINGREQ 报文。表示服务端还活着。 —注意：保持连接（Keep Alive）处理中用到这个报文 2.14 DISCONNECT – 断开连接DISCONNECT 报文是客户端发给服务端的最后一个控制报文。表示客户端正常断开连接。服务端在收到 DISCONNECT 报文时： 必须丢弃任何与当前连接关联的未发布的遗嘱消息。 应该关闭网络连接，如果客户端还没有这么做。 3. 服务质量等级3.1 QoS 0: 最多分发一次消息的分发依赖于底层网络的能力。接收者不会发送响应，发送者也不会重试。消息可能送达一次也可能根本没送达。 对于 QoS 0 的分发协议，发送者必须发送 QoS 等于 0，DUP 等于 0 的 PUBLISH 报文。 对于 QoS 0 的分发协议，接收者接受 PUBLISH 报文时同时接受消息的所有权。 3.2 QoS 1: 至少分发一次（推荐）服务质量确保消息至少送达一次。QoS 1 的 PUBLISH 报文的可变报头中包含一个报文标识符，需要PUBACK 报文确认。 3.2.1 对于QoS 1的分发协议，发送者 每次发送新的应用消息都必须分配一个未使用的报文标识符。 发送的 PUBLISH 报文 必须包含报文标识符且 QoS 等于 1，DUP 等于 0。 必须将这个 PUBLISH 报文看作是未确认的 ，直到从接收者那收到对应的 PUBACK 报文。一旦发送者收到 PUBACK 报文，这个报文标识符就可以重用。 3.2.2 对于 QoS 1 的分发协议，接收者 响应的 PUBACK 报文 必须包含一个报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH 报文。 发送了 PUBACK 报文之后，接收者必须将任何包含相同报文标识符的入站 PUBLISH 报文当作一个新的消息，并忽略它的 DUP 标志的值。 3.3 QoS 2: 仅分发一次这是最高等级的服务质量，消息丢失和重复都是不可接受的。使用这个服务质量等级会有额外的开销。 3.3.1 对于 QoS 2 的分发协议，发送者 必须给要发送的新应用消息分配一个未使用的报文标识符。 发送的 PUBLISH 报文 必须包含报文标识符且报文的 QoS 等于 2,，DUP 等于 0。 必须将这个 PUBLISH 报文看作是 未确认的 ，直到从接收者那收到对应的 PUBREC 报文。 收到 PUBREC 报文后 必须发送一个 PUBREL 报文。PUBREL 报文必须包含与原始 PUBLISH 报文相同的报文标识符。 必须将这个 PUBREL 报文看作是未确认的 ，直到从接收者那收到对应的 PUBCOMP 报文。 一旦发送了对应的 PUBREL 报文就 不能重发这个 PUBLISH 报文。一旦发送者收到 PUBCOMP 报文，这个报文标识符就可以重用。 注意：允许发送者在等待确认时使用不同的报文标识符发送后续的 PUBLISH 报文。 3.3.2 对于QoS 2的分发协议，接收者 响应的 PUBREC 报文 必须包含报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH 报文。 在收到对应的 PUBREL 报文之前，接收者 必须发送 PUBREC 报文确认任何后续的具有相同标识符的 PUBLISH 报文。 在这种情况下，它不能重复分发消息给任何后续的接收者。 响应 PUBREL 报文的 PUBCOMP 报文 必须包含与 PUBREL 报文相同的标识符。 发送 PUBCOMP 报文之后，接收者必须将包含相同报文标识符的任何后续 PUBLISH 报文当作一个新的发布。]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本之旅]]></title>
    <url>%2F2018%2F04%2F20%2Fsummary-japan-trip-4_13%2F</url>
    <content type="text"><![CDATA[– 其实2月初就开始准备签证资料了。只是那时快放假了，有些资料不充分，所以就拖到年后上班才接着备齐资料证明。从提交材料才拿到签证(签证+保险花了596，妹的第一次因为没办金卡还好有流水。个人感觉偏贵，朋友用金卡和居住证办的签证才花了300多)，花了近半个月的时间。然后开始买机票(花了1555，如果年前买的话可能更便宜，朋友比我提前几分钟买的票，尽然比我少花了300多，汗！)、订酒店(都是朋友搞定的，5个晚上平摊940)。接着朋友推荐买了大阪周游卡185、交通卡ICOCA138、随身wifi6*8、到银行换了点日元15000円(妹的，去了日本才知道取的现金不够，日本消费不是一般的贵，还好后来办了信用卡)。一切准备就绪后，最后就是用APP搜索计划要景点、路线规划及准备行李了。4月13号出发，6天的行程(计划旅游城市：大阪-Osaka 2~3天、京都-The Kyoto 2天)就这样开始了。 第一天从深圳口岸(还好朋友带了300RMB换了点港币)出发、经过人工通道”一地两检”，然后坐大巴到了香港，接着坐地铁(不是一般的贵，还好充了100)到了机场(香港机场不是一般的大，先是值机取票，然后坐个摆渡车 找个闸口找半天，汗！)，飞到大阪大概是晚上8~9点的样子，不太记得了。一下飞机就给ICOCA卡充值(买的卡里面只有1500円，想想肯定不够的，于是就充了3000円)，接着就是找住的地方了(民宿，很小，大概只有5~6平米的样子吧)。说实话，日本的地铁比较复杂绕来绕去，一开始我们都蒙了，找个公共地跌路线都走来走去饶了很久，朋友说要要坐普通公共地跌的那种比较便宜(像JR、阪急、阪神、特急、急行都比较贵)。就这样下了地铁后跟着google地图导航找到了住的地方(说话了一路上感觉这边的环境真的挺干净的)。很神奇，房东压根不在这，你只要一个大门和住的房子密码就可以拎包入住了。那时已经是晚上10点半了，肚子已经饿的步行了，于是就在街上逛了逛这边的夜市，吃了点小吃(这边的吃的贼贵，几个丸子花了500円，汗!)，一路上都能看到很多写着”居酒屋”的店(其实就相当于一个小型的KTV或者酒吧，可以边喝酒边唱歌)。接着找了个超市买了点早餐和零食然后就回家睡觉去了。 第二天准确的说，这天应该算是游玩的第一天了。这天起的还算早，一吃完早餐就直奔大阪城了，蹭别人的导游的解说(主要讲了讲丰臣秀吉的平生)顺便便拍了点风景照，嘿嘿！紧接着参观了一下天守阁、西之丸庭园和大阪历史博物馆。中午肚子已经饿得不行了(但还是赶着去下午的目的地)，本来想找家便宜点的地方吃饭，没想到附近吃的都那么贵，最后去麦当劳吃了一顿(话说还算相对便宜的)，吃完饭后紧接着下午去了道顿崛(坐船观光)、日本桥(电子产品、动漫、光碟特别多)、心斋桥(购物的天堂)，晚上坐了下HEP FIVE摩天轮、玩了下Wile River、还去了梅田蓝天大厦(在楼顶上看大阪的夜景还是挺不错的)。因为要去的景点比较多，所以玩得比较赶，不想浪费时间，毕竟是请假来旅游的，我和同事的想法是一致的，尽可能的多玩一些景点。还好有周游券，省了不少钱。回去大概已经是晚上10点多了，到了超市买了点早餐、零食，回去喝了点小酒就休息了。 第三天这天起得比较晚，将近10点才动身。早上先去动物园看了看，话说这里的动物确实挺多的，很多没见过。本来还想看看大象的，没想到大象已经永眠了，汗！接着去了四天王寺，由于起得比较晚，所以没去几个景点。下午就按原计划去去了海游馆(说实话，这是我见过海洋生物最多、面积最大的地方)，花了129RMB值了。然后就去坐船观赏，顺便去环球影城看了一下(没进去，门票太贵了)，就在周围瞎逛了逛，顺便买了个便当，把晚饭也给解决了。大概晚上6点半的样子坐上了返回的游船。快上岸的时候发现那个天保山摩天轮很大、而且五颜六色的很漂亮，然后就跟朋友商量去玩了一下，摩天轮上观赏夜景真的很美。由于要去京都，行程比较紧，所以晚上我们就坐地铁到大阪JR站，然后换乘JR京都线到了京都站，接着坐公交到了我们定好的酒店，顺便找了便利店买了早点、零食和两张公交劵(公交太TMD贵了，230円一次，所以就弄了两张公交劵，比刷ICOCA卡更划算)，到酒店已经很晚了，又是30000多步，累趴了。 第四天妹的，今天起得更晚了，睡到下午1点多一点反应去没有，闹钟都没叫醒，晕！起床随便吃了点，下午2点才出的门。话说京都的寺庙不是一般的多，空气也很好，非常适合旅游。游玩的景点有伏见稻荷大社(需要爬山)、三十三间堂(错过了)、清水寺(没进去)、清水坂、八坂神社、衹园、花见小路、鸭川、锦市场。由于去的比较晚，好多景点都关门或者一眼带过了。晚上回到酒店已经是10点多了。 第五天今天起得还算比较早。跟前几天一样，吃了前一天晚上买的零食早点就出发了。上午逛了下二条城、金阁寺。妹的，一个那个小的景点都是世界文化遗产也是醉了，汗！中午还是吃的麦当劳(算是便宜的，别的真的挺贵的)。下午继续做公交，去了天龙寺、岚山，话说人真的很多，由于有些项目收费比较高，所以就没怎么玩了，就沿途看看风景(据说这里是赏樱圣地，可以已经4月樱花已经没了，如果是3个月来的话就好了)、拍了些照片。由于买的是香港至大阪的往返机票，所以我们就买了点特产，晚上赶回了大阪。 第六天这天是日本旅游的最后一天。由于大阪的所以景点(除了环球影城)基本都玩过了，所以最后一天我们选择了逛逛逛。来到日本桥，这边的动漫、电子产品、游戏、还有成人(GD) 比较多。相比之下，大阪更适合购物、京都更适合游玩观光。由于下午的时间比较紧，所以我们随便找了家吃饭的地方把午餐解决了，然后买了蓝牙音箱(好像是双向连接，充满电可以用很久、挺好用的)、还有一根数据线就赶到机场准备回去了。 —下次有机会再去的话，可能会去东京、北海道。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4月份计划]]></title>
    <url>%2F2018%2F04%2F10%2Fsummary-2018-4-10%2F</url>
    <content type="text"><![CDATA[– 惭愧，对着2018年度计划来看，还有很多事情要做。 3月份总结 通过科三、科三考试，拿到驾照。 偶尔跑步、爬山、游玩。 接触过几个女生。可能是我性格(偏内)的原因，还是感觉有种词穷的感觉，让女生也感觉尴尬。 花钱有点大手大脚、大冰的书没坚持看下去， 生活懒散，不愿做饭、吃药。 4月份安排工作方面 试着多与女同事沟通、与男同事交流技术。 容易发脾气的时候试着仍住，想想值不值得? 多与经理交流想法和方案、适当学习其为人处世及管理之道(月底要总结)。 月底更新一次简历。若简历没有新东西则要产生危机感(新技术没跟上? 待遇上不去? 未来何去何从?)。 学习方面 看完自学炒股这本书。 读大冰的书里面的故事。 生活方面 硬着头皮吃药。 跑步、学习游泳。 少玩王者荣耀，不上瘾、不以段位论英雄。多花时间与妹纸用心交流(要认真对待，不能再无所谓了)。 旅游：4月中旬去日本、多了解一些文化、景点，回来记录旅游心得。 – 世上无难事，只要肯用心。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年度计划]]></title>
    <url>%2F2018%2F03%2F16%2Ftask-and-dream-for-2018%2F</url>
    <content type="text"><![CDATA[2018年度计划工作方面 工作环境：尽管现在所在的公司不怎么加班，但感觉待遇和技术很难上去，平常接触的大多是协议(HTTP、MQTT、TCP/UDP)及通信层的封装、数据管理层的封装; 对新的技术接触的很少、晋升至管理级别的可能性几乎为0。所以如果有好的工作机会的话会考虑换个环境，毕竟年纪也不小了，不想再这么耗下去。 业务交流：感觉搞技术这一行的人都有点内向，都不怎么爱说话，见识的世面太少。有时候跟业务人员交流起来比较费劲，程序员总是习惯按照自己思维去解释一下东西，但实际上很多时候这并不是业务人员想要的答案，毕竟他们的需求是推销产品或服务给客户而不是程序员的逻辑。所以思考怎么更合理的站在业务角度去阐述和解释是需要花时间学习的。当国外客户需要一个SDK给他们用时，英语不怎么好的程序员身边可能需要一个业务员帮忙翻译那些接口文档了。 解决方案：当公司或客户提出新需求、软件出现漏洞、开会讨论产生问题，如何快速思考、整合资源、得出单个或多个有效的解决方案是程序员生涯必须要学会的一样技能。 学习方面 专业技术：学习Android插件化、继续学习自定义View。 自学炒股：掌握股票基础知识、买几只股票、学习如何投资。 生活方面 看病：尽可能多做轻运动（跑步、游泳、爬山） 女票：解决单身问题。多与女生接触交流(不要频繁问问题、查户口，用曲解法、冷读法)、适当学习沟通技巧及话术、与女生沟通时尽量”减少理性思考，多用感性表达”。 买房：今年要攒够钱付首付、不要乱花钱、理财。 旅游：4月份计划去日本旅游，做好攻略安排、记录旅游心得。 多看些技术以外的书籍并记录感悟、丰富知识面。 未来计划1. 拍一部爱情、人性方面的微电影。2. 写一本关于记录人生成长故事、情感方面的书。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI系列(一)AS gradle3.0+ so库的生成及使用]]></title>
    <url>%2F2018%2F01%2F15%2Fsummary-jni-01%2F</url>
    <content type="text"><![CDATA[前言NDK(Native Developerment Kit)提供了一系列的工具，咱们可以用它来将c/c++代码打包成so(c/c++函数库)文件。这样做的好处是保护代码(反编译难度大)，提供程序的执行效率(c代码)，并且能够移植到其它平台上。 JNI(Java Native Interface)提供了一些API实现了Java与其它语言(如: c/c++)的通信，咱们可以通过这些API使java方法能够调用c/c++函数。 一）环境搭建下载NDK：打开File-&gt;Settings-&gt;Android SDK-&gt;SDK Tools选中CMake、LLDB及NDK后，点击Apply，软件会自动安装NDK。 二）生成so库1.创建项目JNIApis (勾选Include C++ support) 2. 新建一个JNI API文件，内容如下：123456789package com.hawky.jni;/** * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class JNIApi &#123; public static native String getStringFromC();&#125; 3. 生成.h文件： 执行命令后，可以看到生成了com_hawky_jni_JNIApi.h(接口函数)文件（目的是为了写C代码），内容如下： 4. 接下来就是实现该接口函数： 5. 修改CMakeLists.txt文件，将默认的native-lib替换成JNIApi, c源文件路径替换成src/main/jni/JNIApi.c ，然后sync一下即可。 6. rebuild一下，生成so库文件： 三）使用so库1. 新建项目JNIApiSample（为了区分so库的生成过程） 2. 在src/main 目录下新建jniLibs文件夹，并将之前生成的那些so库文件拷贝至jniLibs文件夹中，然后在build.gradle(app目录下)配置： sourceSets { main { jni.srcDirs = [] } } 3. 编写Native接口文件：1234567891011121314151617package com.hawky.jni;/** * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class JNIApi &#123; public static native String getStringFromC(); static &#123; try &#123; System.loadLibrary(&amp;quot;JNIApi&amp;quot;); &#125; catch (UnsatisfiedLinkError ule) &#123; System.out.println(&amp;quot;loadLibrary(JNIApi),&amp;quot; + ule.getMessage()); &#125; &#125;&#125; 4. 测试JNI接口：123456789public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toast.makeText(this, &amp;quot;Java调用C代码：&amp;quot; + JNIApi.getStringFromC(), Toast.LENGTH_SHORT).show(); &#125;&#125; rebuild后运行一下可以看到手机界面弹出了“Java调用C代码：I’m String from C!”。OK，大功告成。 总结AS越来越人性化了，gradle3.0之后编写JNI代码也没那么麻烦了，咱们只需要关心具体的核心业务逻辑,专注写C，so库配置一下便会自动生成，然后供Java开发者调用。需要注意的是：JNI接口的包名要与C代码里面的包名一致。]]></content>
      <categories>
        <category>JNI系列</category>
      </categories>
      <tags>
        <tag>JNI</tag>
      </tags>
  </entry>
</search>
