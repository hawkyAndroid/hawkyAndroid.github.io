<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android View之心形]]></title>
    <url>%2F2018%2F11%2F16%2Fsummary-view-heart%2F</url>
    <content type="text"><![CDATA[（一）最优因子1234567对于有n段的贝塞尔曲线来说，到控制点的最优距离(因子)是(4/3)*tan(π/(2n))。圆从坐标系来看，由4段圆弧组成，同时对应4个（数据）点。所以圆的数据点到控制点的最优距离因子为 DIS_FACTOR = (4/3)*tan(π/8)，由三角形倍角公式：tana/2 = sina/(1+cosa);可得tanπ/8 = √2 - 1;即 DIS_FACTOR = (4/3)*(√2 - 1) = 0.5522847498307933984022516... （二）心形的实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/** * 自定义View -- 心形（由4段三阶贝塞尔曲线组成） * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class HeartView extends View &#123; // 数据点到达控制点的最佳距离因子 private static final double DIST_FACTOR = 0.552284749831; // 心形变化次数 private static final float mTotalCount = 10; private Paint mPaint; // "心形"曲线 private Path mHeartPath; // 中心点坐标 private int centerX; private int centerY; // 圆的半径（可由参数传入） private float mRadius; // 数据点与控制之间的差值 private float mDifference; // 当前执行次数 private float mCurrentCount; // 4个数据点 private PointF[] mDataPoint = new PointF[4]; // 8个控制点 private PointF[] mControlPoint = new PointF[8]; private Context mContext; private boolean stopFlag = false; public HeartView(Context context) &#123; this(context, null); &#125; public HeartView(Context context, AttributeSet attrs) &#123; super(context, attrs); this.mContext = context; init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setAntiAlias(true); mHeartPath = new Path(); mRadius = DensityUtils.dip2px(mContext, 100); mDifference = (float) (mRadius * DIST_FACTOR); // 初始化数据点 // A mDataPoint[0] = new PointF(mRadius, 0); // B mDataPoint[1] = new PointF(0, -mRadius); // C mDataPoint[2] = new PointF(-mRadius, 0); // D mDataPoint[3] = new PointF(0, mRadius); // 初始化控制点（从最右边逆时针起，开始描点） // A1、A2 mControlPoint[0] = new PointF(mDataPoint[0].x, mDataPoint[0].y - mDifference); mControlPoint[1] = new PointF(mDataPoint[1].x + mDifference, mDataPoint[1].y); // B1、B2 mControlPoint[2] = new PointF(mDataPoint[1].x - mDifference, mDataPoint[1].y); mControlPoint[3] = new PointF(mDataPoint[2].x, mDataPoint[2].y - mDifference); // C1、C2 mControlPoint[4] = new PointF(mDataPoint[2].x, mDataPoint[2].y + mDifference); mControlPoint[5] = new PointF(mDataPoint[3].x - mDifference, mDataPoint[3].y); // D1、D2 mControlPoint[6] = new PointF(mDataPoint[3].x + mDifference, mDataPoint[3].y); mControlPoint[7] = new PointF(mDataPoint[0].x, mDataPoint[0].y + mDifference); &#125; // 2、测量(控制)View的大小 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = measureDimension(DensityUtils.dip2px(mContext, 250), widthMeasureSpec); int height = measureDimension(DensityUtils.dip2px(mContext, 250), heightMeasureSpec); setMeasuredDimension(width, height);// 保存最终测量的宽高 &#125; // 注意：这里defaultSize参数可由自定义属性传入构造方法拿到，这里暂时写死。 private int measureDimension(int defaultSize, int measureSpec) &#123; int result; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize;// 指定大小 &#125; else &#123; result = defaultSize;// 默认大小 if (specMode == MeasureSpec.AT_MOST) &#123; result = Math.min(result, specSize); &#125; &#125; return result; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); this.centerX = w / 2; this.centerY = h / 2; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); DebugLog.e("绘制开始-------1111----"); if (stopFlag) return; // 将坐标系移动到画布中央 canvas.translate(centerX, centerY); // 绘制背景色 canvas.drawColor(Color.CYAN); // 绘制坐标系 drawCoordinateSystem(canvas); // 描点 drawPoints(canvas); // 绘制顶点(A、B、C、D)文本 drawPointText(canvas); // 绘制数据点与控制点进行连线 drawLines(canvas); // 绘制心形曲线 drawHeartCurve(canvas); mCurrentCount++; if (mCurrentCount &lt; mTotalCount) &#123; // 最上面1个数据点上下移 mDataPoint[1].y += 200 / mTotalCount; // 最下面2个控制点往上移 mControlPoint[5].y -= 160 / mTotalCount; mControlPoint[6].y -= 160 / mTotalCount; // 最下面旁边2个控制点往内移 mControlPoint[4].x += 80 / mTotalCount; mControlPoint[7].x -= 80 / mTotalCount; postInvalidateDelayed(100L); &#125; else &#123; // 重置关键点坐标 mCurrentCount = 0; mDataPoint[1].y = -mRadius; mControlPoint[5].y = mDataPoint[3].y; mControlPoint[6].y = mDataPoint[3].y; mControlPoint[4].x = mDataPoint[2].x; mControlPoint[7].x = mDataPoint[0].x; postInvalidateDelayed(1000L); &#125; DebugLog.e("绘制结束-------222----"); &#125; private void drawCoordinateSystem(Canvas canvas) &#123; mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(3F); mPaint.setColor(Color.argb(127, 0, 0, 0)); canvas.drawLine(-centerX, 0, centerX, 0, mPaint); canvas.drawLine(0, -centerY, 0, centerY, mPaint); &#125; private void drawPoints(Canvas canvas) &#123; mPaint.setStrokeWidth(20F); mPaint.setColor(Color.BLACK); canvas.drawPoint(0, 0, mPaint); // 绘制数据点 for (PointF pointF : mDataPoint) &#123; canvas.drawPoint(pointF.x, pointF.y, mPaint);// A、B、C、D &#125; mPaint.setColor(Color.BLUE); // 绘制控制点 for (PointF pointF : mControlPoint) &#123; canvas.drawPoint(pointF.x, pointF.y, mPaint); &#125; &#125; private void drawPointText(Canvas canvas) &#123; mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(2F); mPaint.setColor(Color.RED); mPaint.setTextSize(DensityUtils.sp2px(mContext, 8F)); float fontH = DensityUtils.getFontHeight(mPaint); char[] peakChar = "ABCD".toCharArray(); for (int i = 0; i &lt; mDataPoint.length; i++) &#123; if (i == 1) &#123; canvas.drawText(peakChar, i, 1, mDataPoint[i].x, mDataPoint[i].y - fontH / 2, mPaint); &#125; else if (i == 2) &#123; canvas.drawText(peakChar, i, 1, mDataPoint[i].x - mPaint.measureText(String.valueOf(peakChar[i])), mDataPoint[i].y + fontH, mPaint); &#125; else &#123; canvas.drawText(peakChar, i, 1, mDataPoint[i].x, mDataPoint[i].y + fontH, mPaint); &#125; &#125; &#125; private void drawLines(Canvas canvas) &#123; mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(5F); mPaint.setColor(Color.GRAY); // A canvas.drawLine(mDataPoint[0].x, mDataPoint[0].y, mControlPoint[0].x, mControlPoint[0].y, mPaint); canvas.drawLine(mDataPoint[0].x, mDataPoint[0].y, mControlPoint[7].x, mControlPoint[7].y, mPaint); // B canvas.drawLine(mDataPoint[1].x, mDataPoint[1].y, mControlPoint[1].x, mControlPoint[1].y, mPaint); canvas.drawLine(mDataPoint[1].x, mDataPoint[1].y, mControlPoint[2].x, mControlPoint[2].y, mPaint); // C canvas.drawLine(mDataPoint[2].x, mDataPoint[2].y, mControlPoint[3].x, mControlPoint[3].y, mPaint); canvas.drawLine(mDataPoint[2].x, mDataPoint[2].y, mControlPoint[4].x, mControlPoint[4].y, mPaint); // D canvas.drawLine(mDataPoint[3].x, mDataPoint[3].y, mControlPoint[5].x, mControlPoint[5].y, mPaint); canvas.drawLine(mDataPoint[3].x, mDataPoint[3].y, mControlPoint[6].x, mControlPoint[6].y, mPaint); &#125; private void drawHeartCurve(Canvas canvas) &#123; mPaint.setStyle(Paint.Style.FILL); mPaint.setColor(Color.argb(225, 255, 0, 0)); mHeartPath.reset(); mHeartPath.moveTo(mDataPoint[0].x, mDataPoint[0].y); mHeartPath.cubicTo(mControlPoint[0].x, mControlPoint[0].y, mControlPoint[1].x, mControlPoint[1].y, mDataPoint[1].x, mDataPoint[1].y); mHeartPath.cubicTo(mControlPoint[2].x, mControlPoint[2].y, mControlPoint[3].x, mControlPoint[3].y, mDataPoint[2].x, mDataPoint[2].y); mHeartPath.cubicTo(mControlPoint[4].x, mControlPoint[4].y, mControlPoint[5].x, mControlPoint[5].y, mDataPoint[3].x, mDataPoint[3].y); mHeartPath.cubicTo(mControlPoint[6].x, mControlPoint[6].y, mControlPoint[7].x, mControlPoint[7].y, mDataPoint[0].x, mDataPoint[0].y); canvas.drawPath(mHeartPath, mPaint); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); stopFlag = true; &#125;&#125;]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之蜘蛛网]]></title>
    <url>%2F2018%2F11%2F14%2Fsummary-view-spider%2F</url>
    <content type="text"><![CDATA[（一）基本思路1、绘制多个正多边形。 2、绘制连接顶点并过原点的直线。 3、绘制顶点上的文本。 4、绘制各维度的辐射区域。 （二）SpiderView的实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/** * 自定义View -- 蜘蛛网（正多边形） * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class SpiderView extends View &#123; // 顶点文本 private static final String mPeakTitles = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // 每条线上(过原点)的各维度值(可由参数传入) private double[] mDimenData = &#123;90.0, 80.5, 100.0, 50.9, 20.3, 50.2, 30.7, 70.8&#125;; // 维度最大阀值 private double mMaxThreshold; private Paint mPaint; private Path mPath; // 蜘蛛网区域的宽高 private int mWidth; private int mHeight; // 正多边形最大层外接圆半径(多边形的最大半径) private float mRadius; // 多边形边数 private int mEdgeCount = 8; // 多边形个数 private int mPolygonCount = 6; // 每条边对应的圆心角（正数时为逆时针） private float mCentralAngle; private Context mContext; public SpiderView(Context context) &#123; this(context, null); &#125; // 1、构造（初始化） public SpiderView(Context context, AttributeSet attrs) &#123; super(context, attrs); this.mContext = context; init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setAntiAlias(true); mPath = new Path(); mCentralAngle = (float) ((Math.PI * 2) / mEdgeCount); mMaxThreshold = getMaxThreshold(); &#125; private double getMaxThreshold() &#123; double result = 0.0D; for (double value : mDimenData) &#123; result = Math.max(value, result); &#125; return result; &#125; // 2、测量(控制)View的大小 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = measureDimension(DensityUtils.dip2px(mContext, 250), widthMeasureSpec); int height = measureDimension(DensityUtils.dip2px(mContext, 250), heightMeasureSpec); setMeasuredDimension(width, height);// 保存最终测量的宽高 &#125; // 注意：这里defaultSize参数可由自定义属性传入构造方法拿到，这里暂时写死。 private int measureDimension(int defaultSize, int measureSpec) &#123; int result; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize;// 指定大小 &#125; else &#123; result = defaultSize;// 默认大小 if (specMode == MeasureSpec.AT_MOST) &#123; result = Math.min(result, specSize); &#125; &#125; return result; &#125; // 3、获取控件最终大小（在onLayout中获取可能更精确） @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); this.mWidth = w; this.mHeight = h; this.mRadius = (w / 2) * 0.9f; &#125; // 4、绘制控件 @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 将坐标系移动到画布中央 canvas.translate(mWidth / 2, mHeight / 2); // 设置画布背景色 canvas.drawColor(Color.CYAN); // 绘制多个多边形 drawPolygon(canvas); // 绘制多条直线 drawLines(canvas); // 绘制文本 drawText(canvas); // 绘制辐射区域 drawRegion(canvas); &#125; private void drawPolygon(Canvas canvas) &#123; mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(3F); mPaint.setColor(Color.argb(127, 0, 0, 0)); // 绘制多个多边形 for (int i = 1; i &lt;= mPolygonCount; i++) &#123; float currentR = (mRadius / mPolygonCount) * i;// 当前多边形半径 mPath.reset(); mPath.moveTo(currentR, 0); // 绘制一个多边形（连接多条边） for (int j = 1; j &lt;= mEdgeCount; j++) &#123; float px = (float) (currentR * Math.cos(mCentralAngle * j)); float py = (float) (currentR * Math.sin(mCentralAngle * j)); mPath.lineTo(px, py); &#125; canvas.drawPath(mPath, mPaint); &#125; &#125; private void drawLines(Canvas canvas) &#123; for (int i = 0; i &lt; mEdgeCount; i++) &#123; mPath.reset(); mPath.moveTo(0, 0);// 起点为原点(0,0) float px = (float) (mRadius * Math.cos(mCentralAngle * i)); float py = (float) (mRadius * Math.sin(mCentralAngle * i)); mPath.lineTo(px, py); canvas.drawPath(mPath, mPaint); &#125; &#125; private void drawText(Canvas canvas) &#123; mPaint.setColor(Color.argb(255, 255, 0, 0)); mPaint.setTextSize(DensityUtils.sp2px(mContext, 10F)); char[] titles = mPeakTitles.toCharArray(); // 计算画笔高度 Paint.FontMetrics fm = mPaint.getFontMetrics(); float fontH = (float) Math.ceil(fm.descent - fm.ascent); for (int i = 0; i &lt; mEdgeCount; i++) &#123; float angle = mCentralAngle * i; // 将半径延长一些再描点 float x = (float) ((mRadius + fontH / 2) * Math.cos(angle)); float y = (float) ((mRadius + fontH / 2) * Math.sin(angle)); float fontW = mPaint.measureText(String.valueOf(titles[i])); // 文本长度 canvas.drawText(titles, i, 1, x - fontW / 2, y + fontH / 2, mPaint);// A、B// if (angle &gt;= 0 &amp;&amp; angle &lt;= Math.PI / 2) &#123;// 第四象限 A、B// &#125; else if (angle &gt; Math.PI / 2 &amp;&amp; angle &lt;= Math.PI) &#123;// 三 C、D// &#125; else if (angle &gt; Math.PI &amp;&amp; angle &lt;= 3 * Math.PI / 2) &#123;// 二 E、F// &#125; else if (angle &gt; 3 * Math.PI / 2 &amp;&amp; angle &lt;= 2 * Math.PI) &#123;// 一 G、H// &#125; &#125; &#125; private void drawRegion(Canvas canvas) &#123; mPaint.setColor(Color.argb(200, 74, 132, 251)); mPaint.setStyle(Paint.Style.FILL); mPath.reset(); float circleRadius = DensityUtils.dip2px(mContext, 5); for (int i = 0; i &lt; mEdgeCount; i++) &#123; // 过原点的线长 double lineLen = (mDimenData[i] / mMaxThreshold) * mRadius; // 确保在直线上 float x = (float) (lineLen * Math.cos(mCentralAngle * i)); float y = (float) (lineLen * Math.sin(mCentralAngle * i)); // 描点 canvas.drawCircle(x, y, circleRadius, mPaint); // 连线 if (i == 0) &#123; mPath.moveTo(x, y); &#125; else &#123; mPath.lineTo(x, y); &#125; &#125; canvas.drawPath(mPath, mPaint); &#125; // ********************************************** // // ******* 下面可以暴露一些数据接口、监听 ******** // // ********************************************** // /** * 设置各维度值 * * @param dimenData 维度数组 */ public void setDimenData(double[] dimenData) &#123; this.mDimenData = dimenData; this.mMaxThreshold = getMaxThreshold(); invalidate(); &#125;&#125;]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 属性动画]]></title>
    <url>%2F2018%2F11%2F12%2Fsummary-animaton-01%2F</url>
    <content type="text"><![CDATA[……]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之阴阳鱼]]></title>
    <url>%2F2018%2F11%2F11%2Fsummary-view-yyfish%2F</url>
    <content type="text"><![CDATA[（一）基本思路1、绘制最外层空心圆及白色实心圆。 2、绘制左半圆。 3、添加 1/2 上半圆。 4、减去 1/2 下半圆。 5、最后单独绘制两个 1/8 小圆。 （二）阴阳鱼的绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 自定义View -- 阴阳鱼 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class YYFishView extends View &#123; private Paint mPaint; // 左半圆 private Path mLeftCirclePath; // 上半圆 private Path mTopHalfCirclePath; // 下半圆 private Path mBottomHalfCirclePath; // 阴阳鱼绘制区域 private RectF mFishRegion; // 绘制区域的宽高 private int mWidth; private int mHeight; // 最外层圆的半径 private float mRadius; private Context mContext; public YYFishView(Context context) &#123; this(context, null); &#125; public YYFishView(Context context, AttributeSet attrs) &#123; super(context, attrs); this.mContext = context; init(); &#125; // 1、构造（初始化） private void init() &#123; mPaint = new Paint(); mPaint.setAntiAlias(true); mLeftCirclePath = new Path(); mTopHalfCirclePath = new Path(); mBottomHalfCirclePath = new Path(); mRadius = DensityUtils.dip2px(mContext, 100); mFishRegion = new RectF(-mRadius, -mRadius, mRadius, mRadius); &#125; // 2、测量(控制)View的大小 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = measureDimension(DensityUtils.dip2px(mContext, 250), widthMeasureSpec); int height = measureDimension(DensityUtils.dip2px(mContext, 250), heightMeasureSpec); setMeasuredDimension(width, height);// 保存最终测量的宽高 &#125; // 注意：这里defaultSize参数可由自定义属性传入构造方法拿到，这里暂时写死。 private int measureDimension(int defaultSize, int measureSpec) &#123; int result; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize;// 指定大小 &#125; else &#123; result = defaultSize;// 默认大小 if (specMode == MeasureSpec.AT_MOST) &#123; result = Math.min(result, specSize); &#125; &#125; return result; &#125; // 3、获取绘制区域宽高 @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); this.mWidth = w; this.mHeight = h; &#125; // 4、绘制图形 @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 将坐标系移动到画布中央 canvas.translate(mWidth / 2, mHeight / 2); // 绘制最外层空心圆 mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(5F); mPaint.setColor(Color.GRAY); canvas.drawCircle(0, 0, mRadius, mPaint); // 绘制最外层实心圆 mPaint.setStyle(Paint.Style.FILL); mPaint.setColor(Color.WHITE); canvas.drawCircle(0, 0, mRadius, mPaint); // 为防止每次看的效果可能不一致，这里要重置Path mLeftCirclePath.reset(); mTopHalfCirclePath.reset(); mBottomHalfCirclePath.reset(); // 绘制左半圆 mLeftCirclePath.addArc(mFishRegion, 90, 180); // 添加 1/2 上半圆 mTopHalfCirclePath.addCircle(0, -mRadius / 2, mRadius / 2, Path.Direction.CW); mLeftCirclePath.op(mTopHalfCirclePath, Path.Op.UNION); // 减去 1/2 下半圆 mBottomHalfCirclePath.addCircle(0, mRadius / 2, mRadius / 2, Path.Direction.CW); mLeftCirclePath.op(mBottomHalfCirclePath, Path.Op.DIFFERENCE); mPaint.setColor(Color.BLACK); canvas.drawPath(mLeftCirclePath, mPaint); // 最后再在Y轴绘制两个小圆 mPaint.setColor(Color.BLACK); canvas.drawCircle(0, mRadius / 2, mRadius / 8, mPaint); mPaint.setColor(Color.WHITE); canvas.drawCircle(0, -mRadius / 2, mRadius / 8, mPaint); &#125;&#125;]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之饼图]]></title>
    <url>%2F2018%2F11%2F09%2Fsummary-view-pie%2F</url>
    <content type="text"><![CDATA[（一）基本思路1、先计算数据总和，再计算出个各扇形(饼图)所占的百分比，就可以得到(1圈)360份里各扇形所占的份数(即扫过的角度sweepAngle)。 2、设置一个初始角startAngle，然后根据份数去循环叠加扫过的角度sweepAngle，进而更新扇形的起始角，这样就可以绘制一个完整的闭环饼图了。 （二）Pie的实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 自定义View -- 饼图PieData * &lt;p&gt; * private String name;// 名称 * private float value;// 数值 * private float percent;// 百分比 * &lt;p&gt; * private int color;// 颜色 * private float angle;// 角度（sweepAngle） * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class PieView extends View &#123; // 数据也可来源于外部 private int[] mColors = &#123;Color.RED, Color.GREEN, Color.BLUE, Color.CYAN&#125;; private Paint mPaint; // View的宽、高 private int mWidth; private int mHeight; // 起始角度 private float mStartAngle; // 饼图绘制区域 private RectF mRectF = new RectF(); // 多条饼图数据 private List&lt;PieData&gt; mDataList; public PieView(Context context) &#123; this(context, null); &#125; public PieView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setAntiAlias(true);// 抗锯齿 mPaint.setStyle(Paint.Style.FILL);// 填充 &#125; // 设置起始角度 public void setStartAngle(float startAngle) &#123; this.mStartAngle = startAngle; invalidate(); &#125; // 设置（更新）数据UI public void setData(List&lt;PieData&gt; list) &#123; initData(list); invalidate(); &#125; // 初始化数据（主要目的：设置百分比、初始角度） private void initData(List&lt;PieData&gt; list) &#123; this.mDataList = list; float sumValue = 0;// 数据总和 for (PieData pie : list) &#123; sumValue += pie.getValue(); &#125; for (PieData pie : list) &#123; float percent = pie.getValue() / sumValue; float angle = percent * 360; pie.setPercent(percent);// 设置饼块百分比 pie.setAngle(angle);// 设置饼块角度(正数为顺时针、负数为逆时针) &#125; &#125; // 确定View的大小 @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = w; mHeight = h; float r = (float) ((Math.min(mWidth, mHeight)) / 2 * 0.9);// 饼图半径 mRectF.set(-r, -r, r, r);// 饼图绘制区域 DebugLog.e("mWidth:" + mWidth + ", mHeight:" + mHeight + ", r:" + r); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float currentStartAngle = mStartAngle; // 当前起始角度 canvas.translate(mWidth / 2, mHeight / 2); // 将画布坐标原点移动到中心位置 for (int i = 0, n = mDataList.size(); i &lt; n; i++) &#123; PieData data = mDataList.get(i); mPaint.setColor(mColors[i]); // 绘制扇形 canvas.drawArc(mRectF, currentStartAngle, data.getAngle(), true, mPaint); currentStartAngle += data.getAngle(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之贝赛尔曲线]]></title>
    <url>%2F2018%2F11%2F09%2Fsummary-view-path-bezier%2F</url>
    <content type="text"><![CDATA[（一） 概念(Bézier curve) 贝塞尔曲线是图形开发中的一个重要工具，通过三个点(起点、控制点和终点)确定一条平滑的曲线，又称贝兹曲线或贝济埃曲线。贝塞尔曲线由线段与节点组成，节点是可拖动的支点，线段像是可伸缩的皮筋。其作用是实时控制曲线状态，并可以通过改变控制点的状态实时让曲线进行平滑的状态变化。 （二）绘制曲线用法 绘制一条二阶贝塞尔曲线，必须调用 moveTo()方法定义起点，再调用quadTo(float x1, float y1, float x2, float y2)方法绘制贝塞尔曲线，其中（x1，y1）是控制点，（x2，y2）是终点。说明：控制点的作用是确定曲线的弯曲程度。 123456789101112// 绘制二阶贝塞尔曲线（1个控制点）Path path = new Path();path.moveTo(x, y);// 起始点(x,y)path.quadTo(x1, y1, x2, y2);// 控制点(x1,y1)，终点(x2,y2)canvas.drawPath(path, paint);// 绘制三阶贝塞尔曲线（2个控制点）Path path = new Path();path.moveTo(x, y);// 起始点(x,y)path.cubicTo(float x1, float y1, float x2, float y2, float x3, float y3);// 控制点(x1,y1)、(x2,y2)，终点(x3,y3)canvas.drawPath(path, paint); （三）二阶贝塞尔曲线的实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 自定义View -- 二阶贝塞尔曲线 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class QuadBezierView extends View &#123; private Paint mPaint; private Path mPath; // 中心点坐标 private int centerX; private int centerY; // 数据点（起点） private PointF startPoint; // 数据点（终点） private PointF endPoint; // 控制点 private PointF controlPoint; // 圆点半径 private float mRadius; private Context mContext; public QuadBezierView(Context context) &#123; this(context, null); &#125; public QuadBezierView(Context context, AttributeSet attrs) &#123; super(context, attrs); this.mContext = context; init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setAntiAlias(true); mPath = new Path(); startPoint = new PointF(); endPoint = new PointF(); controlPoint = new PointF(); mRadius = DensityUtils.dip2px(mContext, 5); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); this.centerX = w / 2; this.centerY = h / 2; startPoint.x = centerX - 300; startPoint.y = centerY; endPoint.x = centerX + 300; endPoint.y = centerY; controlPoint.x = centerX; controlPoint.y = centerY - 200; &#125; // 触摸事件：控制点坐标随着手指变化，进而影响贝塞尔曲线的平滑状态 @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: controlPoint.x = event.getX(); controlPoint.y = event.getY(); invalidate(); break; &#125; return true; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制数据点和控制点 mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.FILL); mPaint.setStrokeWidth(20F); canvas.drawCircle(startPoint.x, startPoint.y, mRadius, mPaint); canvas.drawCircle(endPoint.x, endPoint.y, mRadius, mPaint); canvas.drawCircle(controlPoint.x, controlPoint.y, mRadius, mPaint); // 绘制控制连线 mPaint.setStrokeWidth(5F); canvas.drawLine(startPoint.x, startPoint.y, controlPoint.x, controlPoint.y, mPaint); canvas.drawLine(endPoint.x, endPoint.y, controlPoint.x, controlPoint.y, mPaint); // 绘制贝塞尔曲线 mPaint.setColor(Color.argb(225, 237, 77, 52)); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(10F); mPath.reset(); mPath.moveTo(startPoint.x, startPoint.y); mPath.quadTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y); canvas.drawPath(mPath, mPaint); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); DebugLog.e("处理线程、动画等资源的回收操作"); &#125;&#125;]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之Path]]></title>
    <url>%2F2018%2F11%2F08%2Fsummary-view-path%2F</url>
    <content type="text"><![CDATA[（一）Path添加线条注意：Path中任何线段都是有方向性的。 123456789101112131415// 将画笔移动到点A（x，y）的位置，使用的是绝对定位。path.moveTo(float x, float y);// 与moveTo类似。区别是重置上一次操作的最后一个点(上个点成为无效点)path.setLastPoint(float dx, float dy);// 新点在上一个点的基础上偏移（dx，dy），使用的是相对定位(X=x+dx)。path.rMoveTo(float dx, float dy);// 将画笔移动到点A（x，y）的位置，并在上一个点与当前点之前画一条直线。// 使用的是绝对定位。起点默认为坐标系原点。path.lineTo(float x, float y);// 新点在上一个点的基础上偏移（dx，dy）,并在上一个点与当前点之前画一条直线。// 使用的是相对定位(X=x+dx)。path.rLineTo(float dx, float dy);// 在第一个点和最后一个点之前画一条直线，形成闭合区域。path.close(); （二）Path添加图形123456789101112131415161718192021222324252627// 往 Path 对象中添加矩形。其中最后一个参数为矩形的绘制方向(重要)：// CW 表示顺时针，CCW 表示逆时针。path.addRect(new RectF(float left, float top, float right, float bottom), Path.Direction.CCW);// 往 Path 对象中添加圆角矩形。四个角弧度相同(rx,ry)。path.addRoundRect(new RectF(float left, float top, float right, float bottom), rx, ry, Path.Direction.CW);// 往 Path 对象中添加圆角矩形。四个角分别定义不同的弧线弧度。path.addRoundRect(new RectF(float left, float top, float right, float bottom), float[] radii, Path.Direction.CW);// 往 Path 对象中添加椭圆(矩形的内切圆)。path.addOval(new RectF(float left, float top, float right, float bottom), Path.Direction.CW);// 往 Path 对象中添加圆。path.addCircle(float x, float y, float radius, Path.Direction.CW);// 往 Path 对象中添加一段弧。正数为顺时针，负数为逆时针。path.addArc(new RectF(float left, float top, float right, float bottom), float startAngle, float sweepAngle);// 添加一个圆弧到path(如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点)path.arcTo(new RectF(float left, float top, float right, float bottom), float startAngle, float sweepAngle);// 绘制弧线曲线Path path = new Path();path.moveTo(px, py);// 起始点(x,y)// 参数 forceMoveTo 为 true 时，表示开始一个新的图形，不和上一个点进行连接，为 false 时才和上一个点连接。path.arcTo(new RectF(float left, float top, float right, float bottom), float startAngle, float sweepAngle, boolean forceMoveTo); （三）Path高级用法12345678910111213141516171819202122232425262728293031// 判断path是否为空（是否有内容）path.isEmpty();// 判断path是否是一个矩形（推荐与computeBounds配合使用）path.isRect(RectF rect);// 计算Path的边界（计算结果存放在rectF中）RectF rectF = new RectF();path.computeBounds(rectF, boolean exact);// 参数exact已失效// path位移。移动(dx,dy)path.offset(float dx, float dy);// path位移，移动(dx,dy)。注意：如果dst中存在内容时，则dst中原有的内容无效;// 反之存放平移后的path。path.offset(float dx, float dy, Path dst);// 合并两个Pathpath.addPath(Path src);// 将src进行了位移(dx,dy)之后再添加进当前path中path.addPath(Path src, float dx, float dy);// 先进行Matrix矩阵变换，再将src添加到当前pathpath.addPath(Path src, Matrix matrix);// Path重置（不保留内部数据结构，但会保留FillType）path.reset();// Path重置 (会保留内部的数据结构，但不保留FillType)path.rewind(); （四）Path布尔操作（Op）12// 图形运算（求差集）pathA.op(pathB, Path.Op.DIFFERENCE); 运算规则 名称 作用 Path.Op.DIFFERENCE 差集 图形 A 减去与图形 B 重叠的区域后A余下的区域 Path.Op.INTERSECT 交集 图形 A 和图形 B 的重叠区域 Path.Op.REVERSE_DIFFERENCE 反差集 图形 B 减去与图形A重叠的区域后B余下的区域 Path.Op.UNION 并集 包含了图形 A 和图形 B 的所有区域 Path.Op.XOR 补集(异或) 即图形 A 和图形 B 的所有区域减去他们的重叠区域后余下的区域 （五）Path填充类型（FillType）123456789101112131415161718/** Path有4种填充类型 **/// 设置Path填充模式为奇偶模式path.setFillType(Path.FillType.EVEN_ODD);// 设置Path填充模式为反奇偶模式path.setFillType(Path.FillType.INVERSE_EVEN_ODD);// 设置Path填充模式为(不为0)环绕数模式path.setFillType(Path.FillType.WINDING);// 设置Path填充模式为反(不为0)环绕数模式path.setFillType(Path.FillType.INVERSE_WINDING);// 获取当前填充规则path.getFillType();// 判断是否是反向(INVERSE)规则path.isInverseFillTyp();// 切换填充规则(即原有规则与反向规则之间相互切换)path.toggleInverseFillType(); 使用说明：画笔Paint要设置为填充样式(Paint.Style.FILL)才有效。 其中EVEN_ODD和INVERSE_EVEN_ODD、WINDING和INVERSE_WINDING互为反向填充。 1&gt;、EVEN_ODD（画笔填充的是补集XOR） 12345Path path = new Path();path.addCircle(0, 0, 100, Path.Direction.CW);path.setFillType(Path.FillType.EVEN_ODD);// 设置Path填充模式为奇偶模式path.addRect(new RectF(0, 0, 200, 200), Path.Direction.CW);canvas.drawPath(path, paint); 2&gt;、INVERSE_EVEN_ODD（画笔填充的是交集和被矩形边界包裹的部分） 12345Path path = new Path();path.addCircle(0, 0, 100, Path.Direction.CW);path.setFillType(Path.FillType.INVERSE_EVEN_ODD);// 设置Path填充模式为反奇偶模式path.addCircle(50, 50, 100, Path.Direction.CW);canvas.drawPath(path, mPaint); 3&gt;、WINDING（画笔填充的是并集UNION） 12345Path path = new Path();path.addCircle(0, 0, 100, Path.Direction.CW);path.setFillType(Path.FillType.INVERSE_EVEN_ODD);// 设置Path填充模式为环绕数模式path.addCircle(50, 50, 100, Path.Direction.CW);canvas.drawPath(path, mPaint); 4&gt;、INVERSE_WINDING（画笔填充的是去掉并集UNION外，被矩形边界包裹的部分）12345Path path = new Path();path.addCircle(0, 0, 100, Path.Direction.CW);path.setFillType(Path.FillType.INVERSE_EVEN_ODD);// 设置Path填充模式为反环绕数模式path.addCircle(50, 50, 100, Path.Direction.CW);canvas.drawPath(path, mPaint);]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之Color]]></title>
    <url>%2F2018%2F11%2F08%2Fsummary-view-color%2F</url>
    <content type="text"><![CDATA[1、Color模式 Color模式 解释 Alpha8 仅有透明通道(8位) RGB565 屏幕默认模式(16位) ARGB4444 四通道低精度(16位) ARGB8888 四通道高精度(32位) 说明：如ARGB4444则表示有四个通道(ARGB)，每个对应的通道均用4位来描述。 其中 A 、R 、G 、B 的取值范围均为0~255，即16进制的0x00~0xff。 A从0x00到0xff表示从透明到不透明。RGB从0x00到0xff表示颜色从浅到深。 需要注意的是：当RGB全取最小值(0或0x000000)时颜色为黑色，全取最大值(255或0xffffff)时颜色为白色。Alpha通道主要在两个图像混合的时候生效。 2、Color的使用1234567// 系统自带绿色int color = Color.GREEN;// 半透明绿色int color = Color.argb(127, 0, 255, 0); // 带有透明度的绿色int color = 0x9900FF00;]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之Paint和Canvas]]></title>
    <url>%2F2018%2F11%2F07%2Fsummary-view-paint-canvas%2F</url>
    <content type="text"><![CDATA[（一）Paint的属性及使用12345678910111213Paint paint = new Paint();// 创建画笔paint.setAntiAlias(true);// 抗锯齿paint.setColor(Color.GREEN);// 颜色paint.setStyle(Paint.Style.FILL);// 填充paint.setTextAlign(Paint.Align.LEFT);// 向左对齐paint.setTextSize(20f);// 字体大小paint.setTextSkewX(-0.5f);// 倾斜程度0-1paint.setUnderlineText(true);// 下划线paint.setFakeBoldText(true);// 加粗paint.setStrokeWidth(20f);// 笔粗paint.setStrokeJoin(Paint.Join.ROUND);// 拐角样式paint.setStrokeCap(Paint.Cap.ROUND);// 落笔样式paint.reset();// 重置画笔 （二）Canvas的属性及使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Bitmap bitmap = Bitmap.createBitmap(400, 400, Bitmap.Config.ARGB_8888);Canvas canvas = new Canvas(bitmap);// 创建位图作为画布// 绘制位图canvas.drawBitmap(bitmap, left, top, null);// 绘制缩放后的位图canvas.drawBitmap(bmp, srcRect, dstRect, null);// 使用单一颜色填充整个画布canvas.drawColor(Color.RED);canvas.drawRGB(int r, int g, int b);// 绘制点(可绘制出正方形)canvas.drawPoint(x, y, paint);// 绘制连续多个点。// 该方法的参数 pts 是一个数组，从下标 0 开始每 2 个数确定一个点。多余的元素会忽略。canvas.drawPoints(pts, paint);// 绘制连续若干个点。// 从 pts 数组中的第 offset 处开始取出 count 个数字，以 2 个数为一组确实一个点。忽略多余的元素。canvas.drawPoints(pts, offset, count, paint);// 绘制直线。在（startX, startY）和（stopX, stopY）两个点之间绘制一条直线canvas.drawLine(float startX, float startY, float stopX, float stopY, paint);// 绘制多条直线。（每4个点绘制一条线）canvas.drawLines(float[] pts, paint);// 绘制多条直线。// 从 pts 数组中的第 offset 处开始取出 count 个数字，以 4 个数为一组确实一个点。忽略多余的元素。canvas.drawLines(float[] pts, int offset, int count, paint);// 绘制矩形 其中：Rect的4个参数为外接矩形的两个点坐标canvas.drawRect(new Rect(left, top, right, bottom), paint);// drawRectF// 绘制圆角矩形// left、top、right、bottom 构建一个矩形，rx、ry 分别是圆角处的水平半径和垂直半径。canvas.drawRoundRect(new RectF(left, top, right, bottom), float rx, float ry, paint);// 绘制椭圆(可绘制出圆)。参数和(外切)矩形一致canvas.drawOval(new RectF(left, top, right, bottom), paint);// 绘制圆形。其中：（cx、cy）为圆心坐标，radius 为圆的半径canvas.drawCircle(float cx, float cy, float radius, paint);// 弧线和扇形本质上更是相似。概念：弧线是椭圆上的一段，而扇形则是将弧线的两个端点和椭圆中心点使用线条连接形成的闭合区域。// 绘制扇形或弧线。参数 startAngle 表示起始角度，sweepAngle 表示扇形或弧线所占的角度，正数表示顺时针，负数表示逆时针。// useCenter 参数询问是否要使用中心点，为true 表示扇形，为 false 表示弧线。canvas.drawArc(new RectF(float left, float top, float right, float bottom), float startAngle, float sweepAngle, boolean useCenter, paint);// 从指定的位置开始绘制文本。canvas.drawText(char[] text, int index, int count, float x, float y, Paint paint);// 沿着 Path 定义好的路径绘制文本。参数 hOffset 和 vOffset 用于定义文字离 Path 的水平偏移量和垂直偏移量。canvas.drawTextOnPath(char[] text, int index, int count, Path path, float hOffset, floatvOffset, paint);// 使用Picture来录制（保存）Canvas的操作及状态Canvas canvas = picture.beginRecording(500, 500);// 结束录制picture.endRecording();// 绘制矢量图（可能需要关闭硬件加速）注意：是在onDraw方法中绘制canvas.drawPicture(picture)// 绘制矢量图（可能需要关闭硬件加速）canvas.drawPicture(picture, new RectF(float left, float top, float right, float bottom));// 将Picture包装成PictureDrawable，并设置绘制区域。PictureDrawable drawable = new PictureDrawable(picture);drawable.setBounds(new Rect(int left, int top, int right, int bottom));drawable.draw(canvas);// 绘制连线canvas.drawPath(path, paint); （三）Canvas的高级用法1、Canvas的操作的目的是为了让绘制图形更加简单。 所有的画布操作都只影响后续的绘制，对之前已经绘制过的内容没有影响。 2、画布Canvas是由多个图层layer构成的。 123456789101112131415161718192021222324252627282930313233343536// 保存当前画布的全部状态（快照）canvas.save();// 根据参数saveFlags保存画布的部分状态canvas.save(int saveFlags);// 回滚到上一次保存的状态（回滚）canvas.restore();// 按照画布指定位置的状态进行恢复canvas.restoreToCount(int saveCount);// 获取画布的保存次数canvas.getSaveCount(); --- Canvas线性变换的几个操作---// 1、画布移动。基于画布当前位置的相对移动（坐标系原点也随之移动）。// 移动是可以叠加的。canvas.translate(float dx, float dy);// 2、画布缩放(sx,sy)。其中sx,sy为缩放比，正数表示缩放;// 负数则表示缩放后并根据中心轴翻转。// 注意：缩放中心默认就是坐标系原点。缩放是可以叠加的。canvas.scale(float sx, float sy);// 画布缩放(sx,sy)，缩放中心点为(px,py)canvas.scale(float sx, float sy, float px, float py);// 3、画布旋转。degrees为顺时针旋转，负数为逆时针旋转。canvas.rotate(float degrees);// 画布旋转。先旋转degrees角度，再偏移(px,py)单位。旋转是可以叠加的。canvas.rotate(float degrees, float px, float py);// 4、画布斜切。其中sx是将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值。sy同理。// 即画布变换后：X = sx*y + x; Y = sy*x + y。canvas.skew(float sx, float sy);]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之坐标系]]></title>
    <url>%2F2018%2F11%2F07%2Fsummary-view-coordinate_system%2F</url>
    <content type="text"><![CDATA[（一）View的坐标系 – 说明： View的坐标系统是相对于父控件而言的。屏幕左上角为坐标原点：向右为x轴增大方向，向下为y轴增大方向。 1234567getTop(); //获取子View左上角距父View顶部的距离getLeft(); //获取子View左上角距父View左侧的距离getBottom(); //获取子View右下角距父View顶部的距离getRight(); //获取子View右下角距父View左侧的距离 （二）MotionEvent中 get 和 getRaw 的区别12345event.getX(); //触摸点相对于其所在组件(自身)坐标系的坐标event.getY();event.getRawX(); //触摸点相对于屏幕默认坐标系的坐标event.getRawY();]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之绘制篇]]></title>
    <url>%2F2018%2F11%2F05%2Fsummary-view-drawing-01%2F</url>
    <content type="text"><![CDATA[(一) MeasureSpec MeasureSpec是一个32位int值。高2位代表SpecMode测量模式，低30位代表SpecSize相应模式下的测量规格大小。 1.1 SpecMode分为三类1、UNSPECIFIED：父容器不限制View的大小。 2、EXACTLY：对应于LayoutParams中的match_parent和具体的数值。 3、AT_MOST：对应于LayoutParams中的wrap_content。 1.2 MeasureSpec与LayoutParams的对应关系在测量View的时候，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后根据MeasureSpec确定View测量后的宽/高。 (二) View的工作流程2.1 measure：确定View的测量宽/高最佳实践是在onLayout方法中去获取View的测量宽/高 or 最终宽/高。注意：View的measure过程和Activity的生命周期方法不是同步执行的。 2.2 layout：ViewGroup用来确定子元素的位置。– 注意：layout方法确定View本身的位置，而onLayout方法则会确定所有子元素的位置。 2.3 draw：将View绘制到屏幕上1、绘制背景 background.draw(canvas) 2、绘制自己(onDraw) 3、绘制children(dispatchDraw) 4、绘制装饰(onDrawScrollsBars) 2.4 自定义View的一般流程 步骤(序号) 操作 作用 1 构造函数 初始化参数 2 onMeasure() 测量View的大小 3 onSizeChanged() 确定View的大小(一般用于记录View的当前宽高) 4 onLayout() 确定子View的布局(若无子View可不考虑) 5 onDraw() 绘制图形内容 6 提供外部接口 提供接口更新数据 (三) View的注意事项1、让View支持wrap_content； 2、如果有必要，让View支持padding； 3、尽量不要在View中使用Handler(除非是发消息) 4、View中如果有线程或者动画，一定要重写onDetachedFromWindow()方法进行回收资源(单独封装)。 5、View带有滑动嵌套情况时，需要处理好滑动冲突。 – 注意：直接继承View或ViewGroup的控件，padding默认不生效。]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View之滑动篇]]></title>
    <url>%2F2018%2F09%2F30%2Fsummary-view-sliding-01%2F</url>
    <content type="text"><![CDATA[一、View实现滑动的3种方式1、通过View本身提供的scrollTo/scrollBy方法来实现滑动； 2、通过动画给View施加平移效果来实现动画； 3、通过改变View的LayoutParams使得View重新布局从而实现滑动。]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发工具类]]></title>
    <url>%2F2018%2F09%2F25%2Fsummary-android-tools%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617/*** 校验邮箱** @author [*昨日重现*] lhy_ycu@163.com* @since version 1.0*/public static boolean isEmailValid(String email) &#123; Pattern pattern; Matcher matcher; final String EMAIL_PATTERN = "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@" + "[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]&#123;2,&#125;)$"; pattern = Pattern.compile(EMAIL_PATTERN); matcher = pattern.matcher(email); return matcher.matches();&#125; 12345678910/*** 校验文件合法性** @author [*昨日重现*] lhy_ycu@163.com* @since version 1.0*/public static final boolean isLegalFile(File file) &#123; return file != null &amp;&amp; file.exists() &amp;&amp; file.canRead() &amp;&amp; file.isFile() &amp;&amp; file.length() &gt; 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * 测量文字高度(精确度较高) */public static float getFontHeight(Paint paint) &#123; Paint.FontMetrics fm = paint.getFontMetrics(); return (float) Math.ceil(fm.descent - fm.ascent);&#125;/** * 将px值转换为dip或dp值，保证尺寸大小不变 */public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f);&#125;/** * 将dip或dp值转换为px值，保证尺寸大小不变 */public static int dip2px(Context context, float dipValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dipValue * scale + 0.5f);&#125;/** * 将px值转换为sp值，保证文字大小不变 */public static int px2sp(Context context, float pxValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (pxValue / fontScale + 0.5f);&#125;/** * 将sp值转换为px值，保证文字大小不变 */public static int sp2px(Context context, float spValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (spValue * fontScale + 0.5f);&#125;]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android常见问题及方案]]></title>
    <url>%2F2018%2F09%2F20%2Fsummary-question-solution%2F</url>
    <content type="text"><![CDATA[1. APP卡顿问题原因：Android系统每隔16ms会发出VSYNC信号重绘我们的界面(Activity)。(假定刷新帧率由正常的60FPS(Android系统设定的刷新帧率)降到30FPS，用户就会明显感知到卡顿)。由于任何原因导致接收到VSYNC信号的时候无法完成本次刷新操作，就会产生掉帧(卡顿)的现象。 2. ANR无响应问题2.1 ANR触发场景(分类)1. InputDispatching Timeout：输入/触摸事件分发超时5s未响应完毕； 2. BroadcastQueue Timeout：前台广播在10s内、后台广播在60秒内未执行完成； 3. Service Timeout：前台服务在20s内、后台服务在200s内未执行完成； 4. ContentProvider Timeout：内容提供者，在publish过超时10s。 2.2 ANR解决方案1. 开发中使用AndroidPerformanceMonitor检测卡顿进行处理； 2. 任何耗时操作适当的移到异步里； 3. 合理优化布局，避免OverDraw； 4. 优化内存分配，减少GC频率。 –注意：并不是所有的ANR类型都有章可循，很多偶发的ANR受限于当时发生的环境或者系统Bug；因此对ANR，更应该强调预防而不是分析。 3. 内存泄漏问题描述：创建的对象在堆上无法被GC回收，从而导致可用内存慢慢减少。 1. 释放持有对象的引用，使GC及时回收内存； 2. 及时关闭和释放无用资源； 3. 系统服务尽量使用getApplicationContext() 4. 内存抖动问题描述：大量的对象被创建又在短时间内马上被释放（频繁GC会影响帧率，甚至卡顿）。 1. 避免在循环中创建临时对象； 2. 避免在onDraw中创建Paint、Bitmap对象等。 3. 内存泄漏。 5. 线程异步问题1. 线程做的工作越多，它的优先级应该越小，以便它不会造成系统资源紧张。 2. Thread、AsyncTask适合处理单个任务的场景； 3. HandlerThread适合串行处理多任务的场景； 4. IntentService适合处理与UI无关的多任务场景； 5. 当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择，当然也可以使用AsyncTask传入自定义的线程池； 6. 注意线程优先级的设置。 6. 布局优化问题1. 调试GPU过度绘制，将Overdraw降低到合理范围内； 2. 减少嵌套层次及控件个数，保持view的树形结构尽量扁平（使用Hierarchy Viewer可以方便的查看），同时移除所有不需要渲染的view； 3. 使用GPU配置渲染工具，定位出问题发生在具体哪个步骤，使用TraceView精准定位代码； 4. 使用标签，Merge减少嵌套层次、ViewStub延迟初始化。 7. Overdraw过度绘制问题理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，Overdraw由此产生。GPU工具来检测Overdraw(蓝色是可以接受的颜色)： 1. 原色 – 没有过度绘制 – 这部分的像素点只在屏幕上绘制了一次。 2. 蓝色 – 1次过度绘制– 这部分的像素点只在屏幕上绘制了两次。 3. 绿色 – 2次过度绘制 – 这部分的像素点只在屏幕上绘制了三次。 4. 粉色 – 3次过度绘制 – 这部分的像素点只在屏幕上绘制了四次。 5. 红色 – 4次过度绘制 – 这部分的像素点只在屏幕上绘制了五次。 8. Handler内存泄露问题– 注意：Handler需要使用Looper才能切换线程 ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据。数据存储后，只能在指定线程中获取存储的数据。 123456789101112131415161718// 可使用静态内部类 + 弱引用private final WorkHandler mHandler = new WorkHandler(this);private static class WorkHandler extends Handler &#123; private final WeakReference&lt;MainActivity&gt; mActivity; public WorkHandler(MainActivity activity) &#123; mActivity = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = mActivity.get(); if (activity != null) &#123; // ... &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android WakeLock唤醒锁的使用]]></title>
    <url>%2F2018%2F09%2F20%2Fsummary-wakelock-usage%2F</url>
    <content type="text"><![CDATA[WakeLock分类： 标记值 CPU 屏幕 键盘 PARTIAL_WAKE_LOCK 开启 关闭 关闭 SCREEN_DIM_WAKE_LOCK 开启 变暗 关闭 SCREEN_BRIGHT_WAKE_LOCK 开启 变亮 关闭 FULL_WAKE_LOCK 开启 变亮 变亮 注意：API等级17 开始，FULL_WAKE_LOCK 已被弃用，应使用FLAG_KEEP_SCREEN_ON WakeLock使用时机WakeLock使用时机：如断线重连、重新登录这些关键逻辑的执行过程，一旦执行成功就应立即释放WakeLock。 注意： ①注意使用WakeLock最好设置超时时间，这样timeout后系统会自动release。 ②休眠的情况下如何唤醒来执行任务？用AlarmManager。如推送消息发送心跳包，获取信息等。 WakeLock使用实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* Flag Value CPU Screen Keyboard PARTIAL_WAKE_LOCK On Off Off SCREEN_DIM_WAKE_LOCK On Dim Off SCREEN_BRIGHT_WAKE_LOCK On Bright Off FULL_WAKE_LOCK On Bright Bright */public class MqttWakeLock &#123; private static final String TAG = "MQTT-WakeLock"; private static PowerManager.WakeLock mWakelock = null; private static PowerManager.WakeLock createPartialWakeLock(Context context) &#123; PowerManager pm = (PowerManager) context.getApplicationContext() .getSystemService(Context.POWER_SERVICE); if (pm != null) &#123; return pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG); &#125; return null; &#125; /** * 获取唤醒锁 * * @param context 上下文 * @param timeout The timeout after which to release the wake lock, in milliseconds. */ public static void acquire(Context context, long timeout) &#123; if (mWakelock == null) &#123; mWakelock = createPartialWakeLock(context); &#125; if (mWakelock != null &amp;&amp; !mWakelock.isHeld()) &#123; mWakelock.acquire(timeout);// timeout后系统会自动release，无需手动调用release() Log.d(TAG, "[MqttWakeLock] acquire WakeLock"); &#125; &#125; /** * 释放唤醒锁 */ public static void release() &#123; if (mWakelock != null &amp;&amp; mWakelock.isHeld()) &#123; Log.d(TAG, "[MqttWakeLock] release WakeLock"); mWakelock.release(); mWakelock = null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统广播实例]]></title>
    <url>%2F2018%2F09%2F19%2Fsummary-system-broadcast%2F</url>
    <content type="text"><![CDATA[Android 系统广播实例一般而言，应用被系统杀死后，基本无法接收系统广播。 对于只用于应用内的广播，优先使用 LocalBroadcastManager 来进行注册 和发送，LocalBroadcastManager 安全性更好，同时拥有更高的运行效率。 1. 语言切换广播123456789101112131415161718192021/** * 语言切换广播 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class LocaleChangedReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (Intent.ACTION_LOCALE_CHANGED.equals(action)) &#123; Log.d("LOCALE-CHANGED", "[LocaleChangedReceiver] onReceive - " + action); ActivityUtils.finishAll(); android.os.Process.killProcess(android.os.Process.myPid()); // System.exit(0); &#125; &#125;&#125; XML静态注册广播12345678&lt;!-- 语言切换广播监听 --&gt;&lt;receiver android:name="com.xxx.xxx.receiver.LocaleChangeReceiver" android:enabled="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.LOCALE_CHANGED" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 2. 屏幕解锁广播123456789101112131415161718192021/** * 屏幕解锁广播 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class UserPresentReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (Intent.ACTION_USER_PRESENT.equals(action)) &#123; Log.d("UNLOCK-SCREEN", "[UserPresentReceiver] onReceive - " + action); //if (Utils.checkLogin()) &#123; // ... //&#125; &#125; &#125;&#125; XML静态注册广播123456&lt;!-- 解锁广播监听 --&gt; &lt;receiver android:name="com.xxx.xxx.receiver.UserPresentReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.USER_PRESENT" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 3. 网络监听广播1234567891011121314151617181920/** * 网络监听广播 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class NetworkChangedReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (ConnectivityManager.CONNECTIVITY_ACTION.equals(action)) &#123; Log.d("NETWORK-CHANGE", "[NetworkChangedReceiver] onReceive - " + action); // if (Utils.checkLogin() &amp;&amp; Utils.hasNetwork(context)) &#123; // do something.... // &#125; &#125; &#125;&#125; Android 7.0以后必须动态注册CONNECTIVITY_ACTION123NetworkChangedReceiver networkReceiver = new NetworkChangedReceiver();IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);registerReceiver(networkReceiver, filter);]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化之电量篇]]></title>
    <url>%2F2018%2F09%2F19%2Fsummary-performance-battery%2F</url>
    <content type="text"><![CDATA[耗电的模块1、CPU耗电1.1 CPU长期频繁唤醒 1.2 CPU长期高负荷工作 2、屏幕耗电 LCD(液晶显示器)屏幕本身不发光。白色光线由背后的灯管发出，透过屏幕照射到我们的眼睛，所以我们能够看到图像。在显示黑色屏幕的时候，尽管LCD屏幕已经全黑了，但是背面的灯管还是发光，所以我们会在边缘看到白色的光斑。 OLED屏幕的每个像素都是可以独立发光的。当显示全黑时，所有的像素都不发光，其效果近似关屏，因此黑色的显示效果要好于LCD屏幕，且功耗更低。 3、Wifi、数据网络耗电3.1 流量大小 3.2 网络激活次数和间隔 4、GPS耗电GPS处于工作状态的时间长短直接决定了它是否耗电，所以非定位类的APP尽量不要请求用户开启GPS位置权限。 电量优化方案及检测工具1、CPU1.1 锁屏、灭屏时：释放WakeLock、停止动画绘制、停止扫描等，尽量让CPU休眠。 1.2 若功能需要使用AlarmManager，则可以考虑多个功能合并到一个AlarmManager，且使用过程中要考虑网络变化、用户登录状态改变等场景。 可使用工具TraceView，获取进程执行信息，定位CPU占用率异常的问题。 2、Wifi、网络传输2.1 压缩数据（流量）大小、请求集中处理、选择更快的传输方式。 2.2 减少网络激活次数、增加网络请求间隔。 3、GPS3.1 不同的场景以及不同类型的App对定位更加需要个性化的区分（选择合适的Location Provider、及时注销定位监听、多模块使用定位尽量复用）。 4、Sensor使用传感器，选择合适的采样率，越高的采样率类型则越费电。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化之测试工具篇]]></title>
    <url>%2F2018%2F08%2F29%2Fsummary-performance-detect-tools%2F</url>
    <content type="text"><![CDATA[1. 常用检测方法及工具1.1 获取内存使用情况通过命令行adb shell dumpsys meminfo packagename查看内存详细占用情况 1.2 获取堆内存最大值 DebugLog.e(“堆内存最大值：” + Runtime.getRuntime().maxMemory()); 1.3 反编译APK(可查看方法数) https://github.com/google/android-classyshark –注意：Android默认没有虚拟内存。App占用内存越多，被Low Memory Killer(劫富济贫)处理掉的机会越大。 1.4 查看应用的进程优先级123$ adb ps | grep [package_name] #获取应用pid$ cat /proc/[pid]/ oom_adj #获取进程优先级 –注意：oom_adj越小、优先级越大 1.5 查看ANR日志adb pull /data/anr/traces.txt e:\trace.txt 1.6 查看嵌套层次及控件个数–检测工具：Hierarchy Viewer –&gt; https://github.com/romainguy/ViewServer 1.7 检测内存泄漏BlockCanary(A transparent ui-block detection library for Android) 2. 网络检测工具2.1. 抓包工具(入门级)：FiddlerFiddler是一款http协议调试代理工具，可延迟HTTP返回。 2.2. 模拟网络请求：Postman(安装谷歌插件即可) chrome://apps2.3. Stecho(调试神器) chrome://inspect可用于查看布局层级、网络抓包、查看数据库、SharedPreferences文件等数据。具体配置及初始化见官网。 2.4. 协议(流量)分析神器：WireShark– WireShark可查看封包详细信息如下： Frame: 物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 网络层IP包头部信息 Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP Hypertext Transfer Protocol: 应用层的信息，此处是HTTP协议 – 常用过滤方式 http.request.method == &quot;POST&quot; &amp;&amp; ip.src == 192.168.xxx.xxx http.request.method == &quot;GET&quot; || ip.dst == 192.168.xxx.xxx ip.dst == 192.168.xxx.xxx &amp;&amp; udp ip.src == 192.168.xxx.xxx || tcp tcp.port == XXXX tcp.dstport == XXXX http.host == &quot;www.xxx.com&quot; 2.5. 验收测试工具：FitnesseFitnesse使用参考 启动：java -jar D:\fitnesse-standalone.jar -p 2222 使用实例：FitNesse验收测试Case !define TEST_SYSTEM {slim} !path D:\eclipse\workspace\fitnesse\bin |import | |com.leo.restful | |com.leo.restful.Calculator| |first|second|addition?|minus?|multiply?|divide?|doPost?| |4 |3 | | | | | | 2.6. 压力测试工具：JMeter、XMeter(收费)HTTP测试参考 MQTT测试参考]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化之磁盘篇]]></title>
    <url>%2F2018%2F08%2F28%2Fsummary-performance-disk%2F</url>
    <content type="text"><![CDATA[–参考书籍：《Android移动性能实战》 1. StrictMode12345678910111213141516171819// 在Applcation/Activity的onCreate方法中使用严苛模式：if (BuildConfig.DEBUG) &#123; // 严苛模式-1：使用线程策略 StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectDiskReads() .detectDiskWrites() .detectNetwork() .penaltyLog() .build()); // 严苛模式-2：使用VM策略（可与线程策略一起使用） StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectActivityLeaks() .detectLeakedSqlLiteObjects() .penaltyLog() .build());&#125;---查看日志： adb logcat | grep StrictMode其它用法：直接提示(自定义) StrictMode.noteSlowCall("slowCall timeout=" + timeout); 2. 文件操作 避免冗余读/写：要尽量延迟写入(如：对于SharedPreferences，只保留最后一个apply即可)。 减少I/O操作次数：使用6~8KB Buffer读/写、批量更新数据库使用事务。 使用LruCache和DiskLruCache做内存和磁盘缓存； 不建议在进程间通信中使用SharedPreferences，因为高并发的读写访问可能会丢失数据。 3. 数据库操作3.1 缓存数据库连接数据库在打开后，先不要关闭，在应用程序退出时再关闭。 3.2 使用索引可提高查询速度，但由于要维护索引会使插入效率有所降低。 3.3 尽量不使用Autoincrement关键字 作用：会保证主键是严格单调递增的，如果行号的最大值被用过，那么插入新数据时会包SQLITE_FULL错误。 原理：SQLite创建一个叫sqlite_sequence的内部表来记录该表使用的最大行号，维护sqlite_sequence表带来的额外开销会导致INSERT效率降低。 总结：autoincrement会增加CPU、内存、磁盘空间和磁盘I/O的负担，所以尽量不要用，除非必需(如：客户端需要拿该主键和服务器校对数据，需要保证主键唯一性) 3.4 数据库操作移到工作线程 数据库及IO操作都移到工作线程(Thread)，并且设置线程优先级为THREAD_PRIORITY_BACKGROUND，这样工作线程最多能获取到10%的时间片，优先保证主线程执行。 4. Bitmap操作4.1 提高Bitmap解码效率可考虑使用decodeStream、decodeResourceStream，并传入BufferedInputStream参数。 4.2 TinyPng由于PNG是一种无损格式，JPG是有损格式。所有：小尺寸、色彩较少或者有alpha通道透明度的时候，使用PNG; 大尺寸、色彩渐变多的使用JPG。—图片压缩工具：TinyPng 4.3 合理选择Bitmap.ConfigBitmap.Config用来描述图片的像素是怎么被存储的： ARGB_8888: 每个像素4字节. 共32位，默认设置。 Alpha_8: 只保存透明度，共8位，1字节。 ARGB_4444: 共16位，2字节。 RGB_565:共16位，2字节，只存储RGB值(推荐)。 4.4 WebP格式图片WebP既支持有损压缩也支持无损压缩。体积小，但占用CPU内存是JPG格式的3倍。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发规范总结]]></title>
    <url>%2F2018%2F07%2F29%2Fsummary-develop-standard%2F</url>
    <content type="text"><![CDATA[Android 命令规范 类名：名词+动词+组件名。(activity/fragment/adapter/receiver/provider/service) 布局组件ID：组件缩写_模块缩写具体业务 组件变量：m组件缩写+具体含义，如mIvAvatar string.xml：模块名简称activity名字简称具体意思简称 方法命名：initXX（初始化）、isXX/checkXX（检查数据）、handleXX/processXX（处理数据）、displayXX/showXX（显示控件/数据）、updateXX（更新控件/数据）、saveXX/insertXX（保存数据）、resetXX（重置控件/数据）、drawXX（绘制控件） 代码设计原则1)找出应用中可能需要改变的地方，把它们“抽取”出来并进行“封装”。 2)针对接口编程。 3)多用组合，少用继承。 4)对扩展开放，对修改关闭。 5)依赖倒置：要依赖抽象(不管是高层组件还是底层组件)，不要依赖具体类。 代码注释规范File-&gt;Settings-&gt;Editor-&gt;Code Style-&gt;File and Code Templates Files-&gt; Class 123456789/** @Project: $&#123;PROJECT_NAME&#125;* @FileName: $&#123;NAME&#125;* @Package $&#123;PACKAGE_NAME&#125;* @Author lhy_ycu@163.com* @Date $&#123;DATE&#125; $&#123;TIME&#125;* @Copyright: $&#123;YEAR&#125; www.hank-tech.com Inc. All rights reserved.* @Version V1.0*/ Includes-&gt; File Header 12345/** * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android屏幕适配]]></title>
    <url>%2F2018%2F07%2F29%2Fsummary-android-screen-adaptation%2F</url>
    <content type="text"><![CDATA[Res资源下的文件夹说明 anim：存放组件动画文件。 drawable：存放组件属性(含选择器)样式文件、.9图片。 drawable-xxhdpi：存放图片。 mipmap-xxhdpi：存放图标。 raw：原生流(音视频)文件。 Android 屏幕适配方案 适应大部分屏幕时：使用自动生多个屏幕分辨率values-XXXxXXX/dimen配置文件工具。适用范围：边距、字体大小等都用px(像素)。注意：虚拟按键时需要减去虚拟按键高度(略小于差值也可以)。 适应异形、宽屏、平板等小部分屏幕时：需要手动编写多个相应的layout-XXXxXXX/actvity_xxx文件。 横竖屏切换时： ①新建layout-land（横向布局文件夹） 和 layout-port （竖想布局文件夹），然后要在配置Activity的时候进行如下的配置：android:configChanges=”keyboardHidden|orientation” ②不重启Activity：一般需要重写Activity的onConfigurationChanged方法： 12345678910111213@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) &#123; //切换到竖屏 //修改布局文件 setContentView(R.layout.activity_main); &#125; else if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) &#123; //切换到横屏 //修改布局文件 setContentView(R.layout.activity_main); &#125;&#125; ③重启Activity：一般需要重写onSaveInstanceState、onRestoreInstanceState方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import android.content.Context;import android.content.res.Resources;import android.util.DisplayMetrics;import android.util.TypedValue;import android.view.Display;import android.view.WindowManager;import android.widget.LinearLayout;import java.lang.reflect.Method;/** * 像素单位转换工具类 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class DensityUtils &#123; private DensityUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException("cannot be instantiated"); &#125; /** * dp转px */ public static int dp2px(Context context, float dpVal) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpVal, context.getResources().getDisplayMetrics()); &#125; /** * dp转px */ public static int dp2px(float dpVal) &#123; final float scale = Resources.getSystem().getDisplayMetrics().density; return (int) (dpVal * scale + 0.5f); &#125; /** * px转dp */ public static float px2dp(Context context, float pxVal) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (pxVal / scale); &#125; /** * sp转px */ public static int sp2px(Context context, float spVal) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spVal, context.getResources().getDisplayMetrics()); &#125; /** * px转sp */ public static float px2sp(Context context, float pxVal) &#123; return (pxVal / context.getResources().getDisplayMetrics().scaledDensity); &#125; /** * 获取布局参数 */ public static LinearLayout.LayoutParams getLayoutParams(int height) &#123; LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, DensityUtils.dp2px(height)); layoutParams.setMargins(DensityUtils.dp2px(10), DensityUtils.dp2px(10), DensityUtils.dp2px(10), 0); return layoutParams; &#125; /** * 获取屏幕原始尺寸高度（含虚拟功能键高度） */ public static int getTotalHeight(Context context) &#123; WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); Display display = windowManager.getDefaultDisplay(); DisplayMetrics displayMetrics = new DisplayMetrics(); try &#123; Class c = Class.forName("android.view.Display"); @SuppressWarnings("unchecked") Method method = c.getMethod("getRealMetrics", DisplayMetrics.class); method.invoke(display, displayMetrics); return displayMetrics.heightPixels; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0; &#125; /** * 获取屏幕内容高度(不含虚拟按键) */ public static int getScreenHeight(Context context) &#123; WindowManager wm = (WindowManager) context .getSystemService(Context.WINDOW_SERVICE); DisplayMetrics outMetrics = new DisplayMetrics(); wm.getDefaultDisplay().getMetrics(outMetrics); return outMetrics.heightPixels; &#125;&#125; 附上像素文件生成工具(来源网络)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.PrintWriter;/** * values-XXXxXXX/dimens.xml 像素文件生成工具 */public class GenerateValueFiles &#123; private int baseW; private int baseH; private String dirStr = "./res"; private final static String WTemplate = " &lt;dimen name=\"x&#123;0&#125;\"&gt;&#123;1&#125;px&lt;/dimen&gt;\n"; private final static String HTemplate = " &lt;dimen name=\"y&#123;0&#125;\"&gt;&#123;1&#125;px&lt;/dimen&gt;\n"; /** * &#123;0&#125;-HEIGHT */ private final static String VALUE_TEMPLATE = "values-&#123;0&#125;x&#123;1&#125;"; private static final String SUPPORT_DIMESION = "320,480;480,800;480,854;540,960;600,1024;720,1184;720,1196;720,1280;768,1024;800,1280;1080,1812;1080,1920;1440,2560;"; private String supportStr = SUPPORT_DIMESION; public GenerateValueFiles(int baseX, int baseY, String supportStr) &#123; this.baseW = baseX; this.baseH = baseY; if (!this.supportStr.contains(baseX + "," + baseY)) &#123; this.supportStr += baseX + "," + baseY + ";"; &#125; this.supportStr += validateInput(supportStr); System.out.println(supportStr); File dir = new File(dirStr); if (!dir.exists()) &#123; dir.mkdir(); &#125; System.out.println(dir.getAbsoluteFile()); &#125; /** * @param supportStr * w,h_...w,h; * @return */ private String validateInput(String supportStr) &#123; StringBuffer sb = new StringBuffer(); String[] vals = supportStr.split("_"); int w = -1; int h = -1; String[] wh; for (String val : vals) &#123; try &#123; if (val == null || val.trim().length() == 0) continue; wh = val.split(","); w = Integer.parseInt(wh[0]); h = Integer.parseInt(wh[1]); &#125; catch (Exception e) &#123; System.out.println("skip invalidate params : w,h = " + val); continue; &#125; sb.append(w + "," + h + ";"); &#125; return sb.toString(); &#125; public void generate() &#123; String[] vals = supportStr.split(";"); for (String val : vals) &#123; String[] wh = val.split(","); generateXmlFile(Integer.parseInt(wh[0]), Integer.parseInt(wh[1])); &#125; &#125; private void generateXmlFile(int w, int h) &#123; StringBuffer sbForWidth = new StringBuffer(); sbForWidth.append("&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"); sbForWidth.append("&lt;resources&gt;\n"); float cellw = w * 1.0f / baseW; System.out.println("width : " + w + "," + baseW + "," + cellw); for (int i = 1; i &lt; baseW; i++) &#123; sbForWidth.append(WTemplate.replace("&#123;0&#125;", i + "").replace("&#123;1&#125;", change(cellw * i) + "")); &#125; sbForWidth.append(WTemplate.replace("&#123;0&#125;", baseW + "").replace("&#123;1&#125;", w + "")); sbForWidth.append("&lt;/resources&gt;"); StringBuffer sbForHeight = new StringBuffer(); sbForHeight.append("&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"); sbForHeight.append("&lt;resources&gt;\n"); float cellh = h * 1.0f / baseH; System.out.println("height : " + h + "," + baseH + "," + cellh); for (int i = 1; i &lt; baseH; i++) &#123; sbForHeight.append(HTemplate.replace("&#123;0&#125;", i + "").replace("&#123;1&#125;", change(cellh * i) + "")); &#125; sbForHeight.append(HTemplate.replace("&#123;0&#125;", baseH + "").replace("&#123;1&#125;", h + "")); sbForHeight.append("&lt;/resources&gt;"); File fileDir = new File(dirStr + File.separator + VALUE_TEMPLATE.replace("&#123;0&#125;", h + "")// .replace("&#123;1&#125;", w + "")); fileDir.mkdir(); File layxFile = new File(fileDir.getAbsolutePath(), "lay_x.xml"); File layyFile = new File(fileDir.getAbsolutePath(), "lay_y.xml"); try &#123; PrintWriter pw = new PrintWriter(new FileOutputStream(layxFile)); pw.print(sbForWidth.toString()); pw.close(); pw = new PrintWriter(new FileOutputStream(layyFile)); pw.print(sbForHeight.toString()); pw.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static float change(float a) &#123; int temp = (int) (a * 100); return temp / 100f; &#125; public static void main(String[] args) &#123; int baseW = 320; int baseH = 400; String addition = ""; try &#123; if (args.length &gt;= 3) &#123; baseW = Integer.parseInt(args[0]); baseH = Integer.parseInt(args[1]); addition = args[2]; &#125; else if (args.length &gt;= 2) &#123; baseW = Integer.parseInt(args[0]); baseH = Integer.parseInt(args[1]); &#125; else if (args.length &gt;= 1) &#123; addition = args[0]; &#125; &#125; catch (NumberFormatException e) &#123; System.err.println("right input params : java -jar xxx.jar width height w,h_w,h_..._w,h;"); e.printStackTrace(); System.exit(-1); &#125; new GenerateValueFiles(baseW, baseH, addition).generate(); &#125;&#125;]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的启动模式及其应用场景]]></title>
    <url>%2F2018%2F07%2F19%2Fsummary-activity-launch-mode%2F</url>
    <content type="text"><![CDATA[1. Task任务栈(1)程序打开时就创建了一个任务栈, 用于存储当前程序的activity,所有的activity属于一个任务栈。 (2)一个任务栈包含了一个activity的集合, 去有序的选择哪一个activity和用户进行交互:只有在任务栈栈顶的activity才可以跟用户进行交互。 (3)任务栈可以移动到后台, 并且保留了每一个activity的状态. 并且有序的给用户列出它们的任务, 而且还不丢失它们状态信息。 (4)退出应用程序时：当把所有的任务栈中所有的activity清除出栈时,任务栈会被销毁,程序退出。 2.LaunchMode启动模式启动模式（launchMode）在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。 3 Activity一共有4个启动模式3.1 standardstandard模式是默认的启动模式。不管有没有已存在的实例，都生成新的实例。 3.2 singleTop(栈顶复用)singleTop启动模式，如果Activity实例已经位于栈顶，则不再生成新的实例；反则生成新的实例。使用场景：singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面。 3.3 singleTask(栈内复用-单例模式)singleTask启动模式，发现有对应的Activity实例，则使此Activity实例之上的其它的Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。使用场景：例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 3.4 singleInstancesingleInstance这种启动模式比较特殊，因为它会启用一个新的栈结构，将Activity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。使用场景：singleInstance适合需要与程序分离开的页面。例如闹铃提醒(将闹铃提醒与闹铃设置分离)， 呼叫来电界面等。 补充内容 1&gt; Activity被异常销毁关键执行顺序：onSaveInstanceState(保存数据)、onStop、onStart、onRestoreInstanceState(恢复数据)。而onPause可能执行在onSaveInstanceState前，也可能在其后。 2&gt; onPause：主要做一些存储数据、停止动画等工作；onPause必须执行完，新的Activity的onResume才会执行。 3&gt; 如果一个进程中没有四大组件在执行，那么这个进程将很快被系统杀死。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP 使用详解]]></title>
    <url>%2F2018%2F06%2F01%2Fsummary-udp-01%2F</url>
    <content type="text"><![CDATA[UDP的使用范例BroadcastData -广播数据包对象1234567891011121314151617181920212223242526272829303132package com.leo.udp;/** * 接收的广播数据包 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class BroadcastData &#123; private PacketRx packetRx; private String ip; private int port; public BroadcastData(PacketRx packetRx, String ip, int port) &#123; this.packetRx = packetRx; this.ip = ip; this.port = port; &#125; public PacketRx getPacketRx() &#123; return packetRx; &#125; public String getIp() &#123; return ip; &#125; public int getPort() &#123; return port; &#125;&#125; BroadcastRunnable -广播发送线程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.leo.udp;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;import java.net.SocketException;/** * UDP广播一直发送：每秒发1次 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class BroadcastRunnable implements Runnable &#123; private static final String TAG = BroadcastRunnable.class.getSimpleName(); private static final String FIXED_BROADCAST_IP = "255.255.255.255"; private static final int FIXED_BROADCAST_PORT = 9002; private static final long FIXED_BROADCAST_PERIOD = 1000L; private DatagramSocket mSocket = null; private volatile boolean stop = false; public BroadcastRunnable() &#123; &#125; /** * 停止广播 */ public void stopBroadcast() &#123; this.stop = true; if (mSocket != null) &#123; try &#123; if (!mSocket.isClosed()) &#123; mSocket.close(); &#125; mSocket.disconnect(); mSocket = null; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; @Override public void run() &#123; System.out.println("-----start BroadcastThread-----"); try &#123; mSocket = new DatagramSocket(); mSocket.setBroadcast(true); byte[] data; // 待发送的数据包、待赋值 DatagramPacket packet = new DatagramPacket(data, data.length, new InetSocketAddress(FIXED_BROADCAST_IP, FIXED_BROADCAST_PORT)); System.out.println("Broadcast Address:" + packet.getSocketAddress()); while (!stop) &#123; mSocket.send(packet); System.out.println("Broadcast data send success &gt;&gt;" + bytesToHexString(data)); Thread.sleep(FIXED_BROADCAST_PERIOD); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; stopBroadcast(); System.out.println("-----end BroadcastThread-----"); &#125;&#125; ReceiveRunnable -广播接收线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.leo.udp;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;/** * 接收UDP数据包 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class ReceiveRunnable implements Runnable &#123; private static final String TAG = ReceiveRunnable.class.getSimpleName(); private static final String FIXED_BROADCAST_IP = "255.255.255.255"; private static final int FIXED_BROADCAST_PORT = 58888; private DatagramSocket mSocket = null; private volatile boolean stop = false; private BroadcastDataListener mOnDataListener; public ReceiveRunnable(BroadcastDataListener listener) &#123; this.mOnDataListener = listener; &#125; /** * 停止广播 */ public void stopBroadcast() &#123; this.stop = true; if (mSocket != null) &#123; try &#123; if (!mSocket.isClosed()) &#123; mSocket.close(); &#125; mSocket.disconnect(); mSocket = null; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; @Override public void run() &#123; System.out.println("-----start ReceiveThread-----"); try &#123; mSocket = new DatagramSocket(new InetSocketAddress(FIXED_BROADCAST_IP, FIXED_BROADCAST_PORT)); mSocket.setBroadcast(true); while (!stop) &#123; byte[] data = new byte[128];// 大小需要结合实际情况来定 DatagramPacket packet = new DatagramPacket(data, data.length); mSocket.receive(packet);// 接收广播数据包 // 这里可将data解析（解密）封装成数据包对象packetRx // ... System.out.println("Socket Address:" + packet.getSocketAddress()); System.out.println("receive broadcast data--&lt;&lt;" + packetRx); if (mOnDataListener != null) &#123; mOnDataListener.onReceiveData(new BroadcastData(packetRx, packet.getAddress().getHostAddress(), packet.getPort())); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; stopBroadcast(); System.out.println("-----end ReceiveThread-----"); &#125;&#125; BroadcastDataListener -广播数据包监听1234567891011package com.leo.udp;/** * 监听广播数据包 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public interface BroadcastDataListener &#123; void onReceiveData(BroadcastData broadcastData);&#125; ThreadPoolManager -线程池管理1234567891011121314151617181920212223242526272829303132package com.leo.tcp;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 线程池管理 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class ThreadPoolManager &#123; private ExecutorService service; private ThreadPoolManager() &#123; // 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 service = Executors.newCachedThreadPool(); &#125; public void execute(Runnable runnable) &#123; service.execute(runnable);// 仍到线程池中 &#125; public static ThreadPoolManager getInstance() &#123; return Holder.INSTANCE; &#125; private static class Holder &#123; private static final ThreadPoolManager INSTANCE = new ThreadPoolManager(); &#125;&#125;]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP 使用详解]]></title>
    <url>%2F2018%2F06%2F01%2Fsummary-tcp-01%2F</url>
    <content type="text"><![CDATA[TCP的使用范例SocketClient -客户端对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.leo.tcp;import java.io.IOException;import java.net.Socket;/** * Socket客户端 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class SocketClient &#123; private Socket socket; private String ip; private int port; public SocketClient(Socket socket, String ip, int port) &#123; this.socket = socket; this.ip = ip; this.port = port; &#125; /** * 发送数据给Socket客户端 * * @param data * 加密后的数据 */ public void sendData(byte[] data) throws IOException &#123; if (socket != null &amp;&amp; data != null) &#123; socket.getOutputStream().write(data); &#125; &#125; /** * 关闭Socket客户端 */ public void close() &#123; if (socket == null) return; try &#123; socket.getInputStream().close(); &#125; catch (IOException e) &#123; // e.printStackTrace(); &#125; try &#123; socket.getOutputStream().close(); &#125; catch (IOException e) &#123; // e.printStackTrace(); &#125; if (this.socket != null) &#123; try &#123; this.socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; this.socket = null; System.out.println(ip + "----Socket client closed----"); &#125; public Socket getSocket() &#123; return socket; &#125; public String getIp() &#123; return ip; &#125; public int getPort() &#123; return port; &#125; @Override public String toString() &#123; return "SocketClient [socket=" + socket + ", ip=" + ip + ", port=" + port + "]"; &#125;&#125; TCPClientRunnable -客户端线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.leo.tcp;import java.io.BufferedInputStream;import java.io.DataInputStream;import java.io.IOException;/** * 单独封装一个线程来处理客户端接收的数据 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class TCPClientRunnable implements Runnable &#123; private static final String TAG = TCPClientRunnable.class.getSimpleName(); private volatile boolean stop = false; private SocketClient mSocketClient;// Socket客户端 public TCPClientRunnable(SocketClient socketClient) &#123; this.mSocketClient = socketClient; &#125; @Override public void run() &#123; System.out.println("-----start TCPClientThread-----"); DataInputStream br = null; System.out.println("Socket client is coming---" + mSocketClient.getIp() + ":" + mSocketClient.getPort()); try &#123; br = new DataInputStream(new BufferedInputStream(mSocketClient.getSocket().getInputStream()));// 读取客户端数据(每次循环读取一条完整的数据指令) while (!stop) &#123; int head = 0xFF &amp; br.readByte();// 没有数据时处于阻塞状态 System.out.println("head:" + head); if (head != 0xFF) continue;// 需要根据协议来定 int length = br.readShort();// 需要根据协议来定，这里写死2字节 System.err.println("length:" + length); byte[] buff = new byte[length];// 总的具体数据大小 int hasRead;// 每次读的数据长度 int totalRead = 0;// 累计读的数据长度 while ((hasRead = br.read(buff, totalRead, length - totalRead)) != -1) &#123;// length - totalRead：剩余数据长度 totalRead += hasRead; if (totalRead &gt;= length) break; &#125; // 下面可以将：head、length、buff（具体消息体）（解密）封装成一个包对象packetRx // ... // 提供回调接口，方便UI更新 for (TCPCallback callback : TCPServerRunnable.sDeviceMessageCallbacks) &#123; callback.onReceiveMessage(mSocketClient, packetRx); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; this.stop = true; if (br != null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; synchronized (TCPServerRunnable.sSocketClients) &#123; TCPServerRunnable.sSocketClients.remove(mSocketClient); System.out.println("The number of Socket client is：" + TCPServerRunnable.sSocketClients.size()); // 客户端数量发生变化 for (TCPCallback callback : TCPServerRunnable.sDeviceMessageCallbacks) &#123; callback.onClientsChanged(TCPServerRunnable.sSocketClients); &#125; &#125; System.out.println("-----end TCPClientThread-----"); &#125;&#125; TCPServerRunnable -服务器线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.leo.tcp;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.Collections;import java.util.HashSet;import java.util.Set;import java.util.concurrent.CopyOnWriteArrayList;/** * TCP服务线程 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class TCPServerRunnable implements Runnable &#123; private static final String TAG = TCPServerRunnable.class.getSimpleName(); /** * Socket客户端集合 */ static Set&lt;SocketClient&gt; sSocketClients = Collections.synchronizedSet(new HashSet&lt;SocketClient&gt;()); /** * 设备数据回调监听（只针对多个界面更新，不针对Socket客户端） */ public static CopyOnWriteArrayList&lt;TCPCallback&gt; sDeviceMessageCallbacks = new CopyOnWriteArrayList&lt;&gt;(); /** * TCP服务 默认端口58888 */ public static final int DEFAULT_TCP_PORT = 58888; /** * TCP端口随机生成 */ private int tcpPort = DEFAULT_TCP_PORT; private volatile boolean stop = true; private ServerSocket mServerSocket = null; public TCPServerRunnable() &#123; &#125; public int getTcpPort() &#123; return tcpPort; &#125; public boolean isStop() &#123; return stop; &#125; @Override public void run() &#123; System.out.println("-----start TCPServerThread-----"); try &#123; mServerSocket = new ServerSocket(0); // 获取随机端口 tcpPort = mServerSocket.getLocalPort(); System.out.println("Socket server waiting connect...tcpPort:" + tcpPort); stop = false; while (!stop) &#123; // 等待连接, 此时线程处于阻塞状态 Socket socket = mServerSocket.accept(); // 60s读取超时 socket.setSoTimeout(60 * 1000); // 这里需要判断：如果来了一个已存在的IP-Socket，则需要断开原来的连接 SocketClient socketClient = findSocketClientByIP(socket.getInetAddress().getHostAddress()); if (socketClient != null) &#123; socketClient.close(); try &#123; Thread.sleep(500L); &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); &#125; &#125; socketClient = new SocketClient(socket, socket.getInetAddress().getHostAddress(), socket.getPort()); synchronized (sSocketClients) &#123; sSocketClients.add(socketClient); System.out.println("The number of Socket client is：" + sSocketClients.size()); // 客户端数量发生变化 for (TCPCallback callback : sDeviceMessageCallbacks) &#123; callback.onClientsChanged(sSocketClients); &#125; &#125; ThreadPoolManager.getInstance().execute(new TCPClientRunnable(socketClient)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; stopTCPServer(); System.out.println("-----end TCPServerThread-----"); &#125; /** * 停止TCP服务 */ public void stopTCPServer() &#123; this.stop = true; if (mServerSocket != null) &#123; try &#123; mServerSocket.close(); closeAllSocketClient(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mServerSocket = null; &#125; &#125; /** * 关闭所有Socket客户端 */ private void closeAllSocketClient() &#123; synchronized (sSocketClients) &#123; for (SocketClient client : sSocketClients) &#123; client.close(); &#125; &#125; &#125; /** * 通过IP获取SocketClient * * @param ip * IP地址 * @return Socket客户端 */ public SocketClient findSocketClientByIP(String ip) &#123; for (SocketClient client : sSocketClients) &#123; if (ip.equals(client.getIp())) &#123; return client; &#125; &#125; return null; &#125; /** * 通过IP向某个客户端发消息 */ public void sendDataByIP(String ip, byte[] data) throws IOException &#123; SocketClient client = findSocketClientByIP(ip); if (client != null) &#123; client.sendData(data); &#125; &#125;&#125; ThreadPoolManager -线程池管理1234567891011121314151617181920212223242526272829303132package com.leo.tcp;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 线程池管理 * * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class ThreadPoolManager &#123; private ExecutorService service; private ThreadPoolManager() &#123; // 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 service = Executors.newCachedThreadPool(); &#125; public void execute(Runnable runnable) &#123; service.execute(runnable);// 仍到线程池中 &#125; public static ThreadPoolManager getInstance() &#123; return Holder.INSTANCE; &#125; private static class Holder &#123; private static final ThreadPoolManager INSTANCE = new ThreadPoolManager(); &#125;&#125;]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket知识点总结]]></title>
    <url>%2F2018%2F05%2F31%2Fsummary-socket-01%2F</url>
    <content type="text"><![CDATA[计算机网络分层计算机网络分为五层：物理层、数据链路层、网络层、传输层、应用层。其中：网络层：负责根据IP找到目的地址的主机。传输层：通过端口把数据传到目的主机的目的进程，来实现进程与进程之间的通信。 C/S结构定义：即客户端/服务器结构，是软件系统体系结构作用：充分利用两端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。Socket正是使用这种结构建立连接的，一个套接字接客户端，一个套接字接服务器。 Socket的使用类型主要有两种：流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务 TCP协议定义：Transmission Control Protocol，即传输控制协议，是一种传输层通信协议。三次握手的目的是为了防止服务器端因为接收了早已失效的连接请求报文从而一直等待客户端请求，从而浪费资源。 特点：面向连接、面向字节流、全双工通信、可靠.①面向连接：指的是要使用TCP传输数据，必须先建立TCP连接，传输完成后释放连接，就像打电话一样必须先拨号建立一条连接，打完后挂机释放连接。 ②全双工通信：即一旦建立了TCP连接，通信双方可以在任何时候都能发送数据。 ③可靠的：指的是通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。 ④面向字节流：流，指的是流入到进程或从进程流出的字符序列。简单来说，虽然有时候要传输的数据流太大，TCP报文长度有限制，不能一次传输完，要把它分为好几个数据块，但是由于可靠性保证，接收方可以按顺序接收数据块然后重新组成分块之前的数据流，所以TCP看起来就像直接互相传输字节流一样，面向字节流。 UDP协议定义：User Datagram Protocol，即用户数据报协议，是一种传输层通信协议。 特点：无连接的、不可靠的、面向报文、没有拥塞控制.无连接的：和TCP要建立连接不同，UDP传输数据不需要建立连接，就像写信，在信封写上收信人名称、地址就可以交给邮局发送了，至于能不能送到，就要看邮局的送信能力和送信过程的困难程度了。 不可靠的：因为UDP发出去的数据包发出去就不管了，不管它会不会到达，所以很可能会出现丢包现象，使传输的数据出错。 面向报文：数据报文，就相当于一个数据包，应用层交给UDP多大的数据包，UDP就照样发送，不会像TCP那样拆分。 没有拥塞控制：拥塞，是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象，就像交通堵塞一样。TCP建立连接后如果发送的数据因为信道质量的原因不能到达目的地，它会不断重发，有可能导致越来越塞，所以需要一个复杂的原理来控制拥塞。而UDP就没有这个烦恼，发出去就不管了。 UDP协议应用场景很多的实时应用（如IP电话、实时视频会议、某些多人同时在线游戏等）要求源主机以很定的速率发送数据，并且允许在网络发生拥塞时候丢失一些数据，但是要求不能有太大的延时，UDP就刚好适合这种要求。所以说，只有不适合的技术，没有真正没用的技术。 Socket 与 Http 对比 工作性质不同。Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题。而HTTP协议 属于 应用层，解决的是数据如何包装的问题。 工作方式不同。Http：采用 请求-响应 方式即建立网络连接后，当 客户端 向 服务器 发送请求后，服务器端才能向客户端返回数据。可理解为：是客户端有需要才进行通信。而Socket：采用 服务器主动发送数据 的方式即建立网络连接后，服务器可主动发送消息给客户端，而不需要由客户端向服务器发送请求可理解为：是服务器端有需要才进行通信。]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS使用总结]]></title>
    <url>%2F2018%2F05%2F30%2Fsummary-as-develop-2018-5-28%2F</url>
    <content type="text"><![CDATA[android gradle依赖的几种方式implementation使用了该命令编译的依赖，它仅仅对当前的Moudle提供接口。好处： 1. 加快编译速度。2. 隐藏对外不必要的接口。 api跟 2.x 版本的 compile完全相同。与implementation的区别是：implementation内部module使用，而api可对外提供接口。 provided（compileOnly）只在编译时有效，不会参与打包可以在自己的moudle中使用该方式依赖一些比如com.android.support，gson这些使用者常用的库，避免冲突。 apk（runtimeOnly）只在生成apk的时候参与打包，编译时不会参与，很少用。]]></content>
      <categories>
        <category>AS总结</category>
      </categories>
      <tags>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为人处世]]></title>
    <url>%2F2018%2F05%2F27%2Fsummary-do-something-2018-5-27%2F</url>
    <content type="text"><![CDATA[看望病友：安慰、鼓励、善意的“欺骗”。 日常朋友聊天：谦逊、求同存异、“不离间”。 问朋友借东西：用商量的语气、别说气话、礼貌归还。 为朋友劝架：心平气和、用幽默解围、不要有个人情绪。 邻里相处：平等、表扬、切勿探究别人的私事。 对朋友下逐客令：把理由说清楚、商量性的提醒、安排他干点别的事。 在酒桌上说话：话题顾忌他人，尊重宾主、别强求劝酒。 同事之间：巧用称谓搞好关系、不要过分表现自己、建设性口气。 寻找陌生人之间话题：发现共同点、话题符合身份、避免过多使用专业术语、尽量选择众人关心的事件、不要轻易转移话题、虚心请教、换位思考、目的性不要太强。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT协议总结]]></title>
    <url>%2F2018%2F05%2F09%2Fsummary-mqtt-protocol%2F</url>
    <content type="text"><![CDATA[1. MQTT控制报文的格式1.1 MQTT控制报文的结构 MQTT控制报文的结构 Fixed header 固定报头，所有控制报文都包含 Variable header 可变报头，部分控制报文包含 Payload 有效载荷，部分控制报文包含 1.2 固定报头（2个字节） Bit 7 6 5 4 3 2 1 0 byte 1 MQTT控制报文的类型 用于指定控制报文类型的标志位 byte 2 剩余长度 1.2.1 控制报文的类型（14种）–高四位 名字 值 报文流动方向 描述 Reserved 0 禁止 保留 CONNECT 1 客户端到服务端 客户端请求连接服务端 CONNACK 2 服务端到客户端 连接报文确认 PUBLISH 3 两个方向都允许 发布消息 PUBACK 4 两个方向都允许 QoS 1 消息发布收到确认 PUBREC 5 两个方向都允许 发布收到（保证交付第一步） PUBREL 6 两个方向都允许 发布释放（保证交付第二步） PUBCOMP 7 两个方向都允许 QoS 2 消息发布完成（保证交互第三步） SUBSCRIBE 8 客户端到服务端 客户端订阅请求 SUBACK 9 服务端到客户端 订阅请求报文确认 UNSUBSCRIBE 10 客户端到服务端 客户端取消订阅请求 UNSUBACK 11 服务端到客户端 取消订阅报文确认 PINGREQ 12 客户端到服务端 心跳请求 PINGRESP 13 服务端到客户端 心跳响应 DISCONNECT 14 客户端到服务端 客户端断开连接 Reserved 15 禁止 保留 1.2.2 标志位 –低四位 控制报文 固定报头标志 Bit 3 Bit 2 Bit 1 Bit 0 CONNECT Reserved 0 0 0 0 CONNACK Reserved 0 0 0 0 PUBLISH Used in MQTT 3.1.1 DUP 1 QoS 2 QoS 2 RETAIN 3 PUBACK Reserved 0 0 0 0 PUBREC Reserved 0 0 0 0 PUBREL Reserved 0 0 1 0 PUBCOMP Reserved 0 0 0 0 SUBSCRIBE Reserved 0 0 1 0 SUBACK Reserved 0 0 0 0 UNSUBSCRIBE Reserved 0 0 1 0 UNSUBACK Reserved 0 0 0 0 PINGREQ Reserved 0 0 0 0 PINGRESP Reserved 0 0 0 0 DISCONNECT Reserved 0 0 0 0 1.2.3 剩余长度 –从第 2 个字节开始位置剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。 剩余长度字段使用一个变长度编码方案，对小于 128 的值它使用单字节编码。更大的值按下面的方式处理。低 7 位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码 128 个数值和一个 延续位（ continuation bit ） 。剩余长度字段最大 4 个字节。 分别表示（每个字节的低 7 位用于编码数据，最高位是标志位）：1 个字节时，从 0(0x00)到 127(0x7f)2 个字节时，从 128(0x80,0x01)到 16383(0Xff,0x7f)3 个字节时，从 16384(0x80,0x80,0x01)到 2097151(0xFF,0xFF,0x7F)4 个字节时，从 2097152(0x80,0x80,0x80,0x01)到 268435455(0xFF,0xFF,0xFF,0x7F) 1.3 可变报头某些 MQTT 控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。 很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是 PUBLISH（QoS&gt;0 时），PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。 注意：QoS 设置为 0 的 PUBLISH 报文 不能包含报文标识符。PUBACK, PUBREC, PUBREL 报文 必须包含与最初发送的 PUBLISH 报文相同的报文标识符。类似地，SUBACK 和 UNSUBACK 必须包含在对应的 SUBSCRIBE 和 UNSUBSCRIBE 报文中使用的报文标识符。 1.4 有效载荷某些 MQTT 控制报文在报文的最后部分包含一个有效载荷。对于PUBLIC来说，有效载荷就是应用消息。 1.4.1 包含有效载荷的控制报文 控制报文 有效载荷 CONNECT 需要 CONNACK 不需要 PUBLISH 可选 PUBACK 不需要 PUBREC 不需要 PUBREL 不需要 PUBCOMP 不需要 SUBSCRIBE 需要 SUBACK 需要 UNSUBSCRIBE 需要 PINGRESP 不需要 DISCONNECT 不需要 2. MQTT控制报文（14种）2.1 CONNECT – 连接服务端客户端到服务端的网络连接建立后，客户端发送给服务端的第一个报文必须是CONNECT报文。在一个网络连接上，客户端只能发送一次 CONNECT 报文。服务端 必须将客户端发送的第二个 CONNECT报文当作协议违规处理并断开客户端的连接。有效载荷包含一个或多个编码的字段。包括客户端的唯一标识符，Will 主题，Will 消息，用户名和密码。除了客户端标识之外，其它的字段都是可选的，基于标志位来决定可变报头中是否需要包含这些字段。 2.2 CONNACK – 确认连接请求服务端发送 CONNACK 报文响应从客户端收到的 CONNECT 报文。服务端发送给客户端的第一个报文必须须是 CONNACK。如果客户端在合理的时间内没有收到服务端的 CONNACK 报文，客户端 应该关闭网络连接。合理的时间取决于应用的类型和通信基础设施。 连接返回码的值 值 返回码响应 描述 0 0x00 连接已接受 连接已被服务端接受 1 0x01 连接已拒绝，不支持的协议版本 服务端不支持客户端请求的 MQTT 协议级别 2 0x02 连接已拒绝，不合格的客户端标识符 客户端标识符是正确的 UTF-8 编码，但服务端不允许使用 3 0x03 连接已拒绝，服务端不可用 网络连接已建立，但 MQTT 服务不可用 4 0x04 连接已拒绝，无效的用户名或密码 用户名或密码的数据格式无效 5 0x05 连接已拒绝，未授权 客户端未被授权连接到此服务器 6-255 保留 如果认为上表中的所有连接返回码都不太合适，那么服务端 必须关闭网络连接，不需要发送 CONNACK 报文。 2.3 PUBLISH – 发布消息PUBLISH 控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息。 PUBLISH 报文固定报头 Bit 7 6 5 4 3 2 1 0 byte 1 MQTT控制报文的类型 DUP(重发标志) QoS等级 RETAIN byte 2 剩余长度 备注：① 如果 DUP 标志被设置为 0，表示这是客户端或服务端第一次请求发送这个 PUBLISH 报文。如果 DUP 标志被设置为 1，表示这可能是一个早前报文请求的重发。② QoS=0表示最多分发1次、QoS=1表示至少分发一次、QoS=2表示只分发一次。③ 如果客户端发给服务端的 PUBLISH 报文的保留标志位 0，服务端 不能存储这个消息也 不能移除或替换任何现存的保留消息。④ 服务端发送给订阅客户端的 PUBLISH 报文的主题名 必须匹配该订阅的主题过滤器。 2.4 PUBACK – 发布确认PUBACK 报文是对 QoS 1 等级的 PUBLISH 报文的响应。 2.5 PUBREC – 发布收到PUBREC 报文是对 QoS 等级 2 的 PUBLISH 报文的响应。它是 QoS 2 等级协议交换的第二个报文。 2.6 PUBREL – 发布释放PUBREL 报文是对 PUBREC 报文的响应。它是 QoS 2 等级协议交换的第三个报文。 2.7 PUBCOMP – 发布完成PUBCOMP报文是对PUBREL报文的响应。它是QoS 2等级协议交换的第四个也是最后一个报文。 2.8 SUBSCRIBE - 订阅主题客户端向服务端发送 SUBSCRIBE 报文用于创建一个或多个订阅。每个订阅注册客户端关心的一个或多个主题。为了将应用消息转发给与那些订阅匹配的主题，服务端发送 PUBLISH 报文给客户端。SUBSCRIBE报文也（为每个订阅）指定了最大的 QoS 等级，服务端根据这个发送应用消息给客户端。SUBSCRIBE 报文的有效载荷包含了一个主题过滤器列表，它们表示客户端想要订阅的主题。每一个过滤器后面跟着一个字节，这个字节被叫做服务质量要求（Requested QoS）。它给出了服务端向客户端发送应用消息所允许的最大 QoS 等级。SUBSCRIBE 报文的有效载荷 必须包含至少一对主题过滤器 和 QoS 等级字段组合。服务端收到客户端发送的一个 SUBSCRIBE 报文时， 必须使用 SUBACK 报文响应SUBACK 报文 必须和等待确认的 SUBSCRIBE 报文有相同的报文标识符。 2.9 SUBACK – 订阅确认服务端发送 SUBACK 报文给客户端，用于确认它已收到并且正在处理 SUBSCRIBE 报文。SUBACK 报文包含一个返回码清单，它们指定了 SUBSCRIBE 请求的每个订阅被授予的最大 QoS 等级。SUBACK有效载荷包含一个返回码清单。每个返回码对应等待确认的 SUBSCRIBE 报文中的一个主题过滤器。返回码的顺序 必须和 SUBSCRIBE 报文中主题过滤器的顺序相同。 2.10 UNSUBSCRIBE – 取消订阅客户端发送 UNSUBSCRIBE 报文给服务端，用于取消订阅主题。UNSUBSCRIBE 报文固定报头的第 3,2,1,0 位是保留位且 必须分别设置为 0,0,1,0。服务端 必须认为任何其它的值都是不合法的并关闭网络连接。UNSUBSCRIBE 报文的有效载荷 必须至少包含一个消息过滤器。 2.11 UNSUBACK – 取消订阅确认服务端发送 UNSUBACK 报文给客户端用于确认收到 UNSUBSCRIBE 报文。 2.12 12 PINGREQ – 心跳请求客户端发送 PINGREQ 报文给服务端的。用于： 在没有任何其它控制报文从客户端发给服务的时，告知服务端客户端还活着。 请求服务端发送 响应确认它还活着。 使用网络以确认网络连接没有断开。 —注意：保持连接（Keep Alive）处理中用到这个报文 2.13 PINGRESP – 心跳响应服务端发送 PINGRESP 报文响应客户端的 PINGREQ 报文。表示服务端还活着。 —注意：保持连接（Keep Alive）处理中用到这个报文 2.14 DISCONNECT – 断开连接DISCONNECT 报文是客户端发给服务端的最后一个控制报文。表示客户端正常断开连接。服务端在收到 DISCONNECT 报文时： 必须丢弃任何与当前连接关联的未发布的遗嘱消息。 应该关闭网络连接，如果客户端还没有这么做。 3. 服务质量等级3.1 QoS 0: 最多分发一次消息的分发依赖于底层网络的能力。接收者不会发送响应，发送者也不会重试。消息可能送达一次也可能根本没送达。 对于 QoS 0 的分发协议，发送者必须发送 QoS 等于 0，DUP 等于 0 的 PUBLISH 报文。 对于 QoS 0 的分发协议，接收者接受 PUBLISH 报文时同时接受消息的所有权。 3.2 QoS 1: 至少分发一次（推荐）服务质量确保消息至少送达一次。QoS 1 的 PUBLISH 报文的可变报头中包含一个报文标识符，需要PUBACK 报文确认。 3.2.1 对于QoS 1的分发协议，发送者 每次发送新的应用消息都必须分配一个未使用的报文标识符。 发送的 PUBLISH 报文 必须包含报文标识符且 QoS 等于 1，DUP 等于 0。 必须将这个 PUBLISH 报文看作是未确认的 ，直到从接收者那收到对应的 PUBACK 报文。一旦发送者收到 PUBACK 报文，这个报文标识符就可以重用。 3.2.2 对于 QoS 1 的分发协议，接收者 响应的 PUBACK 报文 必须包含一个报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH 报文。 发送了 PUBACK 报文之后，接收者必须将任何包含相同报文标识符的入站 PUBLISH 报文当作一个新的消息，并忽略它的 DUP 标志的值。 3.3 QoS 2: 仅分发一次这是最高等级的服务质量，消息丢失和重复都是不可接受的。使用这个服务质量等级会有额外的开销。 3.3.1 对于 QoS 2 的分发协议，发送者 必须给要发送的新应用消息分配一个未使用的报文标识符。 发送的 PUBLISH 报文 必须包含报文标识符且报文的 QoS 等于 2,，DUP 等于 0。 必须将这个 PUBLISH 报文看作是 未确认的 ，直到从接收者那收到对应的 PUBREC 报文。 收到 PUBREC 报文后 必须发送一个 PUBREL 报文。PUBREL 报文必须包含与原始 PUBLISH 报文相同的报文标识符。 必须将这个 PUBREL 报文看作是未确认的 ，直到从接收者那收到对应的 PUBCOMP 报文。 一旦发送了对应的 PUBREL 报文就 不能重发这个 PUBLISH 报文。一旦发送者收到 PUBCOMP 报文，这个报文标识符就可以重用。 注意：允许发送者在等待确认时使用不同的报文标识符发送后续的 PUBLISH 报文。 3.3.2 对于QoS 2的分发协议，接收者 响应的 PUBREC 报文 必须包含报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH 报文。 在收到对应的 PUBREL 报文之前，接收者 必须发送 PUBREC 报文确认任何后续的具有相同标识符的 PUBLISH 报文。 在这种情况下，它不能重复分发消息给任何后续的接收者。 响应 PUBREL 报文的 PUBCOMP 报文 必须包含与 PUBREL 报文相同的标识符。 发送 PUBCOMP 报文之后，接收者必须将包含相同报文标识符的任何后续 PUBLISH 报文当作一个新的发布。]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本之旅]]></title>
    <url>%2F2018%2F04%2F20%2Fsummary-japan-trip-4_13%2F</url>
    <content type="text"><![CDATA[– 其实2月初就开始准备签证资料了。只是那时快放假了，有些资料不充分，所以就拖到年后上班才接着备齐资料证明。从提交材料才拿到签证(签证+保险花了596，妹的第一次因为没办金卡还好有流水。个人感觉偏贵，朋友用金卡和居住证办的签证才花了300多)，花了近半个月的时间。然后开始买机票(花了1555，如果年前买的话可能更便宜，朋友比我提前几分钟买的票，尽然比我少花了300多，汗！)、订酒店(都是朋友搞定的，5个晚上平摊940)。接着朋友推荐买了大阪周游卡185、交通卡ICOCA138、随身wifi6*8、到银行换了点日元15000円(妹的，去了日本才知道取的现金不够，日本消费不是一般的贵，还好后来办了信用卡)。一切准备就绪后，最后就是用APP搜索计划要景点、路线规划及准备行李了。4月13号出发，6天的行程(计划旅游城市：大阪-Osaka 2~3天、京都-The Kyoto 2天)就这样开始了。 第一天从深圳口岸(还好朋友带了300RMB换了点港币)出发、经过人工通道”一地两检”，然后坐大巴到了香港，接着坐地铁(不是一般的贵，还好充了100)到了机场(香港机场不是一般的大，先是值机取票，然后坐个摆渡车 找个闸口找半天，汗！)，飞到大阪大概是晚上8~9点的样子，不太记得了。一下飞机就给ICOCA卡充值(买的卡里面只有1500円，想想肯定不够的，于是就充了3000円)，接着就是找住的地方了(民宿，很小，大概只有5~6平米的样子吧)。说实话，日本的地铁比较复杂绕来绕去，一开始我们都蒙了，找个公共地跌路线都走来走去饶了很久，朋友说要要坐普通公共地跌的那种比较便宜(像JR、阪急、阪神、特急、急行都比较贵)。就这样下了地铁后跟着google地图导航找到了住的地方(说话了一路上感觉这边的环境真的挺干净的)。很神奇，房东压根不在这，你只要一个大门和住的房子密码就可以拎包入住了。那时已经是晚上10点半了，肚子已经饿的步行了，于是就在街上逛了逛这边的夜市，吃了点小吃(这边的吃的贼贵，几个丸子花了500円，汗!)，一路上都能看到很多写着”居酒屋”的店(其实就相当于一个小型的KTV或者酒吧，可以边喝酒边唱歌)。接着找了个超市买了点早餐和零食然后就回家睡觉去了。 第二天准确的说，这天应该算是游玩的第一天了。这天起的还算早，一吃完早餐就直奔大阪城了，蹭别人的导游的解说(主要讲了讲丰臣秀吉的平生)顺便便拍了点风景照，嘿嘿！紧接着参观了一下天守阁、西之丸庭园和大阪历史博物馆。中午肚子已经饿得不行了(但还是赶着去下午的目的地)，本来想找家便宜点的地方吃饭，没想到附近吃的都那么贵，最后去麦当劳吃了一顿(话说还算相对便宜的)，吃完饭后紧接着下午去了道顿崛(坐船观光)、日本桥(电子产品、动漫、光碟特别多)、心斋桥(购物的天堂)，晚上坐了下HEP FIVE摩天轮、玩了下Wile River、还去了梅田蓝天大厦(在楼顶上看大阪的夜景还是挺不错的)。因为要去的景点比较多，所以玩得比较赶，不想浪费时间，毕竟是请假来旅游的，我和同事的想法是一致的，尽可能的多玩一些景点。还好有周游券，省了不少钱。回去大概已经是晚上10点多了，到了超市买了点早餐、零食，回去喝了点小酒就休息了。 第三天这天起得比较晚，将近10点才动身。早上先去动物园看了看，话说这里的动物确实挺多的，很多没见过。本来还想看看大象的，没想到大象已经永眠了，汗！接着去了四天王寺，由于起得比较晚，所以没去几个景点。下午就按原计划去去了海游馆(说实话，这是我见过海洋生物最多、面积最大的地方)，花了129RMB值了。然后就去坐船观赏，顺便去环球影城看了一下(没进去，门票太贵了)，就在周围瞎逛了逛，顺便买了个便当，把晚饭也给解决了。大概晚上6点半的样子坐上了返回的游船。快上岸的时候发现那个天保山摩天轮很大、而且五颜六色的很漂亮，然后就跟朋友商量去玩了一下，摩天轮上观赏夜景真的很美。由于要去京都，行程比较紧，所以晚上我们就坐地铁到大阪JR站，然后换乘JR京都线到了京都站，接着坐公交到了我们定好的酒店，顺便找了便利店买了早点、零食和两张公交劵(公交太TMD贵了，230円一次，所以就弄了两张公交劵，比刷ICOCA卡更划算)，到酒店已经很晚了，又是30000多步，累趴了。 第四天妹的，今天起得更晚了，睡到下午1点多一点反应去没有，闹钟都没叫醒，晕！起床随便吃了点，下午2点才出的门。话说京都的寺庙不是一般的多，空气也很好，非常适合旅游。游玩的景点有伏见稻荷大社(需要爬山)、三十三间堂(错过了)、清水寺(没进去)、清水坂、八坂神社、衹园、花见小路、鸭川、锦市场。由于去的比较晚，好多景点都关门或者一眼带过了。晚上回到酒店已经是10点多了。 第五天今天起得还算比较早。跟前几天一样，吃了前一天晚上买的零食早点就出发了。上午逛了下二条城、金阁寺。妹的，一个那个小的景点都是世界文化遗产也是醉了，汗！中午还是吃的麦当劳(算是便宜的，别的真的挺贵的)。下午继续做公交，去了天龙寺、岚山，话说人真的很多，由于有些项目收费比较高，所以就没怎么玩了，就沿途看看风景(据说这里是赏樱圣地，可以已经4月樱花已经没了，如果是3个月来的话就好了)、拍了些照片。由于买的是香港至大阪的往返机票，所以我们就买了点特产，晚上赶回了大阪。 第六天这天是日本旅游的最后一天。由于大阪的所以景点(除了环球影城)基本都玩过了，所以最后一天我们选择了逛逛逛。来到日本桥，这边的动漫、电子产品、游戏、还有成人(GD) 比较多。相比之下，大阪更适合购物、京都更适合游玩观光。由于下午的时间比较紧，所以我们随便找了家吃饭的地方把午餐解决了，然后买了蓝牙音箱(好像是双向连接，充满电可以用很久、挺好用的)、还有一根数据线就赶到机场准备回去了。 —下次有机会再去的话，可能会去东京、北海道。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4月份计划]]></title>
    <url>%2F2018%2F04%2F10%2Fsummary-2018-4-10%2F</url>
    <content type="text"><![CDATA[– 惭愧，对着2018年度计划来看，还有很多事情要做。 3月份总结 通过科三、科三考试，拿到驾照。 偶尔跑步、爬山、游玩。 接触过几个女生。可能是我性格(偏内)的原因，还是感觉有种词穷的感觉，让女生也感觉尴尬。 花钱有点大手大脚、大冰的书没坚持看下去， 生活懒散，不愿做饭、吃药。 4月份安排工作方面 试着多与女同事沟通、与男同事交流技术。 容易发脾气的时候试着仍住，想想值不值得? 多与经理交流想法和方案、适当学习其为人处世及管理之道(月底要总结)。 月底更新一次简历。若简历没有新东西则要产生危机感(新技术没跟上? 待遇上不去? 未来何去何从?)。 学习方面 看完自学炒股这本书。 读大冰的书里面的故事。 生活方面 硬着头皮吃药。 跑步、学习游泳。 少玩王者荣耀，不上瘾、不以段位论英雄。多花时间与妹纸用心交流(要认真对待，不能再无所谓了)。 旅游：4月中旬去日本、多了解一些文化、景点，回来记录旅游心得。 – 世上无难事，只要肯用心。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年度计划]]></title>
    <url>%2F2018%2F03%2F16%2Ftask-and-dream-for-2018%2F</url>
    <content type="text"><![CDATA[2018年度计划工作方面 工作环境：尽管现在所在的公司不怎么加班，但感觉待遇和技术很难上去，平常接触的大多是协议(HTTP、MQTT、TCP/UDP)及通信层的封装、数据管理层的封装; 对新的技术接触的很少、晋升至管理级别的可能性几乎为0。所以如果有好的工作机会的话会考虑换个环境，毕竟年纪也不小了，不想再这么耗下去。 业务交流：感觉搞技术这一行的人都有点内向，都不怎么爱说话，见识的世面太少。有时候跟业务人员交流起来比较费劲，程序员总是习惯按照自己思维去解释一下东西，但实际上很多时候这并不是业务人员想要的答案，毕竟他们的需求是推销产品或服务给客户而不是程序员的逻辑。所以思考怎么更合理的站在业务角度去阐述和解释是需要花时间学习的。当国外客户需要一个SDK给他们用时，英语不怎么好的程序员身边可能需要一个业务员帮忙翻译那些接口文档了。 解决方案：当公司或客户提出新需求、软件出现漏洞、开会讨论产生问题，如何快速思考、整合资源、得出单个或多个有效的解决方案是程序员生涯必须要学会的一样技能。 学习方面 专业技术：学习Android性能优化、继续学习自定义View。 自学炒股：掌握股票基础知识、买几只股票、学习如何投资。 生活方面 看病：尽可能多做轻运动（跑步、游泳、爬山） 女票：解决单身问题。多与女生接触交流(不要频繁问问题、查户口，用曲解法、冷读法)、适当学习沟通技巧及话术、与女生沟通时尽量”减少理性思考，多用感性表达”。 买房：今年要攒够钱付首付、不要乱花钱、理财。 旅游：4月份计划去日本旅游，做好攻略安排、记录旅游心得。 书籍：多看些技术以外的书籍并记录感悟、丰富知识面。 未来计划1. 拍一部爱情、人性方面的微电影。2. 写一本关于记录人生成长故事、情感方面的书。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI系列(一)AS gradle3.0+ so库的生成及使用]]></title>
    <url>%2F2018%2F01%2F15%2Fsummary-jni-01%2F</url>
    <content type="text"><![CDATA[前言NDK(Native Developerment Kit)提供了一系列的工具，咱们可以用它来将c/c++代码打包成so(c/c++函数库)文件。这样做的好处是保护代码(反编译难度大)，提供程序的执行效率(c代码)，并且能够移植到其它平台上。 JNI(Java Native Interface)提供了一些API实现了Java与其它语言(如: c/c++)的通信，咱们可以通过这些API使java方法能够调用c/c++函数。 一）环境搭建下载NDK：打开File-&gt;Settings-&gt;Android SDK-&gt;SDK Tools选中CMake、LLDB及NDK后，点击Apply，软件会自动安装NDK。 二）生成so库1.创建项目JNIApis (勾选Include C++ support) 2. 新建一个JNI API文件，内容如下：123456789package com.hawky.jni;/** * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class JNIApi &#123; public static native String getStringFromC();&#125; 3. 生成.h文件： 执行命令后，可以看到生成了com_hawky_jni_JNIApi.h(接口函数)文件（目的是为了写C代码），内容如下： 4. 接下来就是实现该接口函数： 5. 修改CMakeLists.txt文件，将默认的native-lib替换成JNIApi, c源文件路径替换成src/main/jni/JNIApi.c ，然后sync一下即可。 6. rebuild一下，生成so库文件： 三）使用so库1. 新建项目JNIApiSample（为了区分so库的生成过程） 2. 在src/main 目录下新建jniLibs文件夹，并将之前生成的那些so库文件拷贝至jniLibs文件夹中，然后在build.gradle(app目录下)配置： sourceSets { main { jni.srcDirs = [] } } 3. 编写Native接口文件：1234567891011121314151617package com.hawky.jni;/** * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class JNIApi &#123; public static native String getStringFromC(); static &#123; try &#123; System.loadLibrary(&amp;quot;JNIApi&amp;quot;); &#125; catch (UnsatisfiedLinkError ule) &#123; System.out.println(&amp;quot;loadLibrary(JNIApi),&amp;quot; + ule.getMessage()); &#125; &#125;&#125; 4. 测试JNI接口：123456789public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toast.makeText(this, &amp;quot;Java调用C代码：&amp;quot; + JNIApi.getStringFromC(), Toast.LENGTH_SHORT).show(); &#125;&#125; rebuild后运行一下可以看到手机界面弹出了“Java调用C代码：I’m String from C!”。OK，大功告成。 总结AS越来越人性化了，gradle3.0之后编写JNI代码也没那么麻烦了，咱们只需要关心具体的核心业务逻辑,专注写C，so库配置一下便会自动生成，然后供Java开发者调用。需要注意的是：JNI接口的包名要与C代码里面的包名一致。]]></content>
      <categories>
        <category>JNI系列</category>
      </categories>
      <tags>
        <tag>JNI</tag>
      </tags>
  </entry>
</search>
