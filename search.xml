<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MQTT协议总结]]></title>
    <url>%2F2018%2F05%2F09%2Fsummary_mqtt_protocol%2F</url>
    <content type="text"><![CDATA[1. MQTT控制报文的格式1.1 MQTT控制报文的结构 MQTT控制报文的结构 Fixed header 固定报头，所有控制报文都包含 Variable header 可变报头，部分控制报文包含 Payload 有效载荷，部分控制报文包含 1.2 固定报头（2个字节） Bit 7 6 5 4 3 2 1 0 byte 1 MQTT控制报文的类型 用于指定控制报文类型的标志位 byte 2 剩余长度 1.2.1 控制报文的类型（14种）–高四位 名字 值 报文流动方向 描述 Reserved 0 禁止 保留 CONNECT 1 客户端到服务端 客户端请求连接服务端 CONNACK 2 服务端到客户端 连接报文确认 PUBLISH 3 两个方向都允许 发布消息 PUBACK 4 两个方向都允许 QoS 1 消息发布收到确认 PUBREC 5 两个方向都允许 发布收到（保证交付第一步） PUBREL 6 两个方向都允许 发布释放（保证交付第二步） PUBCOMP 7 两个方向都允许 QoS 2 消息发布完成（保证交互第三步） SUBSCRIBE 8 客户端到服务端 客户端订阅请求 SUBACK 9 服务端到客户端 订阅请求报文确认 UNSUBSCRIBE 10 客户端到服务端 客户端取消订阅请求 UNSUBACK 11 服务端到客户端 取消订阅报文确认 PINGREQ 12 客户端到服务端 心跳请求 PINGRESP 13 服务端到客户端 心跳响应 DISCONNECT 14 客户端到服务端 客户端断开连接 Reserved 15 禁止 保留 1.2.2 标志位 –低四位 控制报文 固定报头标志 Bit 3 Bit 2 Bit 1 Bit 0 CONNECT Reserved 0 0 0 0 CONNACK Reserved 0 0 0 0 PUBLISH Used in MQTT 3.1.1 DUP 1 QoS 2 QoS 2 RETAIN 3 PUBACK Reserved 0 0 0 0 PUBREC Reserved 0 0 0 0 PUBREL Reserved 0 0 1 0 PUBCOMP Reserved 0 0 0 0 SUBSCRIBE Reserved 0 0 1 0 SUBACK Reserved 0 0 0 0 UNSUBSCRIBE Reserved 0 0 1 0 UNSUBACK Reserved 0 0 0 0 PINGREQ Reserved 0 0 0 0 PINGRESP Reserved 0 0 0 0 DISCONNECT Reserved 0 0 0 0 1.2.3 剩余长度 –从第 2 个字节开始位置剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。 剩余长度字段使用一个变长度编码方案，对小于 128 的值它使用单字节编码。更大的值按下面的方式处理。低 7 位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码 128 个数值和一个 延续位（ continuation bit ） 。剩余长度字段最大 4 个字节。 分别表示（每个字节的低 7 位用于编码数据，最高位是标志位）：1 个字节时，从 0(0x00)到 127(0x7f)2 个字节时，从 128(0x80,0x01)到 16383(0Xff,0x7f)3 个字节时，从 16384(0x80,0x80,0x01)到 2097151(0xFF,0xFF,0x7F)4 个字节时，从 2097152(0x80,0x80,0x80,0x01)到 268435455(0xFF,0xFF,0xFF,0x7F) 1.3 可变报头某些 MQTT 控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。 很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是 PUBLISH（QoS&gt;0 时），PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。 注意：QoS 设置为 0 的 PUBLISH 报文 不能包含报文标识符。PUBACK, PUBREC, PUBREL 报文 必须包含与最初发送的 PUBLISH 报文相同的报文标识符。类似地，SUBACK 和 UNSUBACK 必须包含在对应的 SUBSCRIBE 和 UNSUBSCRIBE 报文中使用的报文标识符。 1.4 有效载荷某些 MQTT 控制报文在报文的最后部分包含一个有效载荷。对于PUBLIC来说，有效载荷就是应用消息。 1.4.1 包含有效载荷的控制报文 控制报文 有效载荷 CONNECT 需要 CONNACK 不需要 PUBLISH 可选 PUBACK 不需要 PUBREC 不需要 PUBREL 不需要 PUBCOMP 不需要 SUBSCRIBE 需要 SUBACK 需要 UNSUBSCRIBE 需要 PINGRESP 不需要 DISCONNECT 不需要 2. MQTT控制报文（14种）2.1 CONNECT – 连接服务端客户端到服务端的网络连接建立后，客户端发送给服务端的第一个报文必须是CONNECT报文。在一个网络连接上，客户端只能发送一次 CONNECT 报文。服务端 必须将客户端发送的第二个 CONNECT报文当作协议违规处理并断开客户端的连接。有效载荷包含一个或多个编码的字段。包括客户端的唯一标识符，Will 主题，Will 消息，用户名和密码。除了客户端标识之外，其它的字段都是可选的，基于标志位来决定可变报头中是否需要包含这些字段。 2.2 CONNACK – 确认连接请求服务端发送 CONNACK 报文响应从客户端收到的 CONNECT 报文。服务端发送给客户端的第一个报文必须须是 CONNACK。如果客户端在合理的时间内没有收到服务端的 CONNACK 报文，客户端 应该关闭网络连接。合理的时间取决于应用的类型和通信基础设施。 连接返回码的值 值 返回码响应 描述 0 0x00 连接已接受 连接已被服务端接受 1 0x01 连接已拒绝，不支持的协议版本 服务端不支持客户端请求的 MQTT 协议级别 2 0x02 连接已拒绝，不合格的客户端标识符 客户端标识符是正确的 UTF-8 编码，但服务端不允许使用 3 0x03 连接已拒绝，服务端不可用 网络连接已建立，但 MQTT 服务不可用 4 0x04 连接已拒绝，无效的用户名或密码 用户名或密码的数据格式无效 5 0x05 连接已拒绝，未授权 客户端未被授权连接到此服务器 6-255 保留 如果认为上表中的所有连接返回码都不太合适，那么服务端 必须关闭网络连接，不需要发送 CONNACK 报文。 2.3 PUBLISH – 发布消息PUBLISH 控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息。 PUBLISH 报文固定报头 Bit 7 6 5 4 3 2 1 0 byte 1 MQTT控制报文的类型 DUP(重发标志) QoS等级 RETAIN byte 2 剩余长度 备注：① 如果 DUP 标志被设置为 0，表示这是客户端或服务端第一次请求发送这个 PUBLISH 报文。如果 DUP 标志被设置为 1，表示这可能是一个早前报文请求的重发。② QoS=0表示最多分发1次、QoS=1表示至少分发一次、QoS=2表示只分发一次。③ 如果客户端发给服务端的 PUBLISH 报文的保留标志位 0，服务端 不能存储这个消息也 不能移除或替换任何现存的保留消息。④ 服务端发送给订阅客户端的 PUBLISH 报文的主题名 必须匹配该订阅的主题过滤器。 2.4 PUBACK – 发布确认PUBACK 报文是对 QoS 1 等级的 PUBLISH 报文的响应。 2.5 PUBREC – 发布收到PUBREC 报文是对 QoS 等级 2 的 PUBLISH 报文的响应。它是 QoS 2 等级协议交换的第二个报文。 2.6 PUBREL – 发布释放PUBREL 报文是对 PUBREC 报文的响应。它是 QoS 2 等级协议交换的第三个报文。 2.7 PUBCOMP – 发布完成PUBCOMP报文是对PUBREL报文的响应。它是QoS 2等级协议交换的第四个也是最后一个报文。 2.8 SUBSCRIBE - 订阅主题客户端向服务端发送 SUBSCRIBE 报文用于创建一个或多个订阅。每个订阅注册客户端关心的一个或多个主题。为了将应用消息转发给与那些订阅匹配的主题，服务端发送 PUBLISH 报文给客户端。SUBSCRIBE报文也（为每个订阅）指定了最大的 QoS 等级，服务端根据这个发送应用消息给客户端。SUBSCRIBE 报文的有效载荷包含了一个主题过滤器列表，它们表示客户端想要订阅的主题。每一个过滤器后面跟着一个字节，这个字节被叫做服务质量要求（Requested QoS）。它给出了服务端向客户端发送应用消息所允许的最大 QoS 等级。SUBSCRIBE 报文的有效载荷 必须包含至少一对主题过滤器 和 QoS 等级字段组合。服务端收到客户端发送的一个 SUBSCRIBE 报文时， 必须使用 SUBACK 报文响应SUBACK 报文 必须和等待确认的 SUBSCRIBE 报文有相同的报文标识符。 2.9 SUBACK – 订阅确认服务端发送 SUBACK 报文给客户端，用于确认它已收到并且正在处理 SUBSCRIBE 报文。SUBACK 报文包含一个返回码清单，它们指定了 SUBSCRIBE 请求的每个订阅被授予的最大 QoS 等级。SUBACK有效载荷包含一个返回码清单。每个返回码对应等待确认的 SUBSCRIBE 报文中的一个主题过滤器。返回码的顺序 必须和 SUBSCRIBE 报文中主题过滤器的顺序相同。 2.10 UNSUBSCRIBE – 取消订阅客户端发送 UNSUBSCRIBE 报文给服务端，用于取消订阅主题。UNSUBSCRIBE 报文固定报头的第 3,2,1,0 位是保留位且 必须分别设置为 0,0,1,0。服务端 必须认为任何其它的值都是不合法的并关闭网络连接。UNSUBSCRIBE 报文的有效载荷 必须至少包含一个消息过滤器。 2.11 UNSUBACK – 取消订阅确认服务端发送 UNSUBACK 报文给客户端用于确认收到 UNSUBSCRIBE 报文。 2.12 12 PINGREQ – 心跳请求客户端发送 PINGREQ 报文给服务端的。用于： 在没有任何其它控制报文从客户端发给服务的时，告知服务端客户端还活着。 请求服务端发送 响应确认它还活着。 使用网络以确认网络连接没有断开。 —注意：保持连接（Keep Alive）处理中用到这个报文 2.13 PINGRESP – 心跳响应服务端发送 PINGRESP 报文响应客户端的 PINGREQ 报文。表示服务端还活着。 —注意：保持连接（Keep Alive）处理中用到这个报文 2.14 DISCONNECT – 断开连接DISCONNECT 报文是客户端发给服务端的最后一个控制报文。表示客户端正常断开连接。服务端在收到 DISCONNECT 报文时： 必须丢弃任何与当前连接关联的未发布的遗嘱消息。 应该关闭网络连接，如果客户端还没有这么做。 3. 服务质量等级3.1 QoS 0: 最多分发一次消息的分发依赖于底层网络的能力。接收者不会发送响应，发送者也不会重试。消息可能送达一次也可能根本没送达。 对于 QoS 0 的分发协议，发送者必须发送 QoS 等于 0，DUP 等于 0 的 PUBLISH 报文。 对于 QoS 0 的分发协议，接收者接受 PUBLISH 报文时同时接受消息的所有权。 3.2 QoS 1: 至少分发一次（推荐）服务质量确保消息至少送达一次。QoS 1 的 PUBLISH 报文的可变报头中包含一个报文标识符，需要PUBACK 报文确认。 3.2.1 对于QoS 1的分发协议，发送者 每次发送新的应用消息都必须分配一个未使用的报文标识符。 发送的 PUBLISH 报文 必须包含报文标识符且 QoS 等于 1，DUP 等于 0。 必须将这个 PUBLISH 报文看作是未确认的 ，直到从接收者那收到对应的 PUBACK 报文。一旦发送者收到 PUBACK 报文，这个报文标识符就可以重用。 3.2.2 对于 QoS 1 的分发协议，接收者 响应的 PUBACK 报文 必须包含一个报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH 报文。 发送了 PUBACK 报文之后，接收者必须将任何包含相同报文标识符的入站 PUBLISH 报文当作一个新的消息，并忽略它的 DUP 标志的值。 3.3 QoS 2: 仅分发一次这是最高等级的服务质量，消息丢失和重复都是不可接受的。使用这个服务质量等级会有额外的开销。 3.3.1 对于 QoS 2 的分发协议，发送者 必须给要发送的新应用消息分配一个未使用的报文标识符。 发送的 PUBLISH 报文 必须包含报文标识符且报文的 QoS 等于 2,，DUP 等于 0。 必须将这个 PUBLISH 报文看作是 未确认的 ，直到从接收者那收到对应的 PUBREC 报文。 收到 PUBREC 报文后 必须发送一个 PUBREL 报文。PUBREL 报文必须包含与原始 PUBLISH 报文相同的报文标识符。 必须将这个 PUBREL 报文看作是未确认的 ，直到从接收者那收到对应的 PUBCOMP 报文。 一旦发送了对应的 PUBREL 报文就 不能重发这个 PUBLISH 报文。一旦发送者收到 PUBCOMP 报文，这个报文标识符就可以重用。 注意：允许发送者在等待确认时使用不同的报文标识符发送后续的 PUBLISH 报文。 3.3.2 对于QoS 2的分发协议，接收者 响应的 PUBREC 报文 必须包含报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH 报文。 在收到对应的 PUBREL 报文之前，接收者 必须发送 PUBREC 报文确认任何后续的具有相同标识符的 PUBLISH 报文。 在这种情况下，它不能重复分发消息给任何后续的接收者。 响应 PUBREL 报文的 PUBCOMP 报文 必须包含与 PUBREL 报文相同的标识符。 发送 PUBCOMP 报文之后，接收者必须将包含相同报文标识符的任何后续 PUBLISH 报文当作一个新的发布。]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本之旅]]></title>
    <url>%2F2018%2F04%2F20%2Fsummary-japan-trip-4_13%2F</url>
    <content type="text"><![CDATA[– 其实2月初就开始准备签证资料了。只是那时快放假了，有些资料不充分，所以就拖到年后上班才接着备齐资料证明。从提交材料才拿到签证(签证+保险花了596，妹的第一次因为没办金卡还好有流水。个人感觉偏贵，朋友用金卡和居住证办的签证才花了300多)，花了近半个月的时间。然后开始买机票(花了1555，如果年前买的话可能更便宜，朋友比我提前几分钟买的票，尽然比我少花了300多，汗！)、订酒店(都是朋友搞定的，5个晚上平摊940)。接着朋友推荐买了大阪周游卡185、交通卡ICOCA138、随身wifi6*8、到银行换了点日元15000円(妹的，去了日本才知道取的现金不够，日本消费不是一般的贵，还好后来办了信用卡)。一切准备就绪后，最后就是用APP搜索计划要景点、路线规划及准备行李了。4月13号出发，6天的行程(计划旅游城市：大阪-Osaka 2~3天、京都-The Kyoto 2天)就这样开始了。 第一天从深圳口岸(还好朋友带了300RMB换了点港币)出发、经过人工通道”一地两检”，然后坐大巴到了香港，接着坐地铁(不是一般的贵，还好充了100)到了机场(香港机场不是一般的大，先是值机取票，然后坐个摆渡车 找个闸口找半天，汗！)，飞到大阪大概是晚上8~9点的样子，不太记得了。一下飞机就给ICOCA卡充值(买的卡里面只有1500円，想想肯定不够的，于是就充了3000円)，接着就是找住的地方了(民宿，很小，大概只有5~6平米的样子吧)。说实话，日本的地铁比较复杂绕来绕去，一开始我们都蒙了，找个公共地跌路线都走来走去饶了很久，朋友说要要坐普通公共地跌的那种比较便宜(像JR、阪急、阪神、特急、急行都比较贵)。就这样下了地铁后跟着google地图导航找到了住的地方(说话了一路上感觉这边的环境真的挺干净的)。很神奇，房东压根不在这，你只要一个大门和住的房子密码就可以拎包入住了。那时已经是晚上10点半了，肚子已经饿的步行了，于是就在街上逛了逛这边的夜市，吃了点小吃(这边的吃的贼贵，几个丸子花了500円，汗!)，一路上都能看到很多写着”居酒屋”的店(其实就相当于一个小型的KTV或者酒吧，可以边喝酒边唱歌)。接着找了个超市买了点早餐和零食然后就回家睡觉去了。 第二天准确的说，这天应该算是游玩的第一天了。这天起的还算早，一吃完早餐就直奔大阪城了，蹭别人的导游的解说(主要讲了讲丰臣秀吉的平生)顺便便拍了点风景照，嘿嘿！紧接着参观了一下天守阁、西之丸庭园和大阪历史博物馆。中午肚子已经饿得不行了(但还是赶着去下午的目的地)，本来想找家便宜点的地方吃饭，没想到附近吃的都那么贵，最后去麦当劳吃了一顿(话说还算相对便宜的)，吃完饭后紧接着下午去了道顿崛(坐船观光)、日本桥(电子产品、动漫、光碟特别多)、心斋桥(购物的天堂)，晚上坐了下HEP FIVE摩天轮、玩了下Wile River、还去了梅田蓝天大厦(在楼顶上看大阪的夜景还是挺不错的)。因为要去的景点比较多，所以玩得比较赶，不想浪费时间，毕竟是请假来旅游的，我和同事的想法是一致的，尽可能的多玩一些景点。还好有周游券，省了不少钱。回去大概已经是晚上10点多了，到了超市买了点早餐、零食，回去喝了点小酒就休息了。 第三天这天起得比较晚，将近10点才动身。早上先去动物园看了看，话说这里的动物确实挺多的，很多没见过。本来还想看看大象的，没想到大象已经永眠了，汗！接着去了四天王寺，由于起得比较晚，所以没去几个景点。下午就按原计划去去了海游馆(说实话，这是我见过海洋生物最多、面积最大的地方)，花了129RMB值了。然后就去坐船观赏，顺便去环球影城看了一下(没进去，门票太贵了)，就在周围瞎逛了逛，顺便买了个便当，把晚饭也给解决了。大概晚上6点半的样子坐上了返回的游船。快上岸的时候发现那个天保山摩天轮很大、而且五颜六色的很漂亮，然后就跟朋友商量去玩了一下，摩天轮上观赏夜景真的很美。由于要去京都，行程比较紧，所以晚上我们就坐地铁到大阪JR站，然后换乘JR京都线到了京都站，接着坐公交到了我们定好的酒店，顺便找了便利店买了早点、零食和两张公交劵(公交太TMD贵了，230円一次，所以就弄了两张公交劵，比刷ICOCA卡更划算)，到酒店已经很晚了，又是30000多步，累趴了。 第四天妹的，今天起得更晚了，睡到下午1点多一点反应去没有，闹钟都没叫醒，晕！起床随便吃了点，下午2点才出的门。话说京都的寺庙不是一般的多，空气也很好，非常适合旅游。游玩的景点有伏见稻荷大社(需要爬山)、三十三间堂(错过了)、清水寺(没进去)、清水坂、八坂神社、衹园、花见小路、鸭川、锦市场。由于去的比较晚，好多景点都关门或者一眼带过了。晚上回到酒店已经是10点多了。 第五天今天起得还算比较早。跟前几天一样，吃了前一天晚上买的零食早点就出发了。上午逛了下二条城、金阁寺。妹的，一个那个小的景点都是世界文化遗产也是醉了，汗！中午还是吃的麦当劳(算是便宜的，别的真的挺贵的)。下午继续做公交，去了天龙寺、岚山，话说人真的很多，由于有些项目收费比较高，所以就没怎么玩了，就沿途看看风景(据说这里是赏樱圣地，可以已经4月樱花已经没了，如果是3个月来的话就好了)、拍了些照片。由于买的是香港至大阪的往返机票，所以我们就买了点特产，晚上赶回了大阪。 第六天这天是日本旅游的最后一天。由于大阪的所以景点(除了环球影城)基本都玩过了，所以最后一天我们选择了逛逛逛。来到日本桥，这边的动漫、电子产品、游戏、还有成人(GD) 比较多。相比之下，大阪更适合购物、京都更适合游玩观光。由于下午的时间比较紧，所以我们随便找了家吃饭的地方把午餐解决了，然后买了蓝牙音箱(好像是双向连接，充满电可以用很久、挺好用的)、还有一根数据线就赶到机场准备回去了。 —下次有机会再去的话，可能会去东京、北海道。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4月份计划]]></title>
    <url>%2F2018%2F04%2F10%2Fsummary-2018-4-10%2F</url>
    <content type="text"><![CDATA[– 惭愧，对着2018年度计划来看，还有很多事情要做。 3月份总结 通过科三、科三考试，拿到驾照。 偶尔跑步、爬山、游玩。 接触过几个女生。可能是我性格(偏内)的原因，还是感觉有种词穷的感觉，让女生也感觉尴尬。 花钱有点大手大脚、大冰的书没坚持看下去， 生活懒散，不愿做饭、吃药。 4月份安排工作方面 试着多与女同事沟通、与男同事交流技术。 容易发脾气的时候试着仍住，想想值不值得? 多与经理交流想法和方案、适当学习其为人处世及管理之道(月底要总结)。 月底更新一次简历。若简历没有新东西则要产生危机感(新技术没跟上? 待遇上不去? 未来何去何从?)。 学习方面 看完自学炒股这本书。 读大冰的书里面的故事。 生活方面 硬着头皮吃药。 跑步、学习游泳。 少玩王者荣耀，不上瘾、不以段位论英雄。多花时间与妹纸用心交流(要认真对待，不能再无所谓了)。 旅游：4月中旬去日本、多了解一些文化、景点，回来记录旅游心得并发表至微信公众号上。 – 世上无难事，只要肯用心。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年度计划]]></title>
    <url>%2F2018%2F03%2F16%2Ftask-and-dream-for-2018%2F</url>
    <content type="text"><![CDATA[2018年度计划工作方面 工作环境：尽管现在所在的公司不怎么加班，但感觉待遇和技术很难上去，平常接触的大多是协议(HTTP、MQTT、TCP/UDP)及通信层的封装、数据管理层的封装; 对新的技术接触的很少、晋升至管理级别的可能性几乎为0。所以如果有好的工作机会的话会考虑换个环境，毕竟年纪也不小了，不想再这么耗下去。 业务交流：感觉搞技术这一行的人都有点内向，都不怎么爱说话，见识的世面太少。有时候跟业务人员交流起来比较费劲，程序员总是习惯按照自己思维去解释一下东西，但实际上很多时候这并不是业务人员想要的答案，毕竟他们的需求是推销产品或服务给客户而不是程序员的逻辑。所以思考怎么更合理的站在业务角度去阐述和解释是需要花时间学习的。当国外客户需要一个SDK给他们用时，英语不怎么好的程序员身边可能需要一个业务员帮忙翻译那些接口文档了。 解决方案：当公司或客户提出新需求、软件出现漏洞、开会讨论产生问题，如何快速思考、整合资源、得出单个或多个有效的解决方案是程序员生涯必须要学会的一样技能。 学习方面 专业技术：学习Android插件化、继续学习自定义View。 自学炒股：掌握股票基础知识、买几只股票、学习如何投资。 拿驾照：争取今年3、4月份通过科三、科四考试、拿到驾驶证。 微信公众号：写故事、文章，并同步至hawky.me托管网站上。 生活方面 看病：尽可能多做轻运动（跑步、游泳、爬山） 女票：解决单身问题。多与女生接触交流(不要频繁问问题、查户口，用曲解法、冷读法)、适当学习沟通技巧及话术、与女生沟通时尽量”减少理性思考，多用感性表达”。 买房：今年要攒够钱付首付、不要乱花钱、理财。 旅游：4月份计划去日本旅游，做好攻略安排、记录旅游心得。 多看些技术以外的书籍并记录感悟、丰富知识面。 未来计划1. 拍一部爱情、人性方面的微电影。2. 写一本关于记录人生成长故事、情感方面的书。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI系列(一)AS gradle3.0+ so库的生成及使用]]></title>
    <url>%2F2018%2F01%2F15%2Fjni-001%2F</url>
    <content type="text"><![CDATA[前言NDK(Native Developerment Kit)提供了一系列的工具，咱们可以用它来将c/c++代码打包成so(c/c++函数库)文件。这样做的好处是保护代码(反编译难度大)，提供程序的执行效率(c代码)，并且能够移植到其它平台上。 JNI(Java Native Interface)提供了一些API实现了Java与其它语言(如: c/c++)的通信，咱们可以通过这些API使java方法能够调用c/c++函数。 一）环境搭建下载NDK：打开File-&gt;Settings-&gt;Android SDK-&gt;SDK Tools选中CMake、LLDB及NDK后，点击Apply，软件会自动安装NDK。 二）生成so库1.创建项目JNIApis (勾选Include C++ support) 2. 新建一个JNI API文件，内容如下：123456789package com.hawky.jni;/** * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class JNIApi &#123; public static native String getStringFromC();&#125; 3. 生成.h文件： 执行命令后，可以看到生成了com_hawky_jni_JNIApi.h(接口函数)文件（目的是为了写C代码），内容如下： 4. 接下来就是实现该接口函数： 5. 修改CMakeLists.txt文件，将默认的native-lib替换成JNIApi, c源文件路径替换成src/main/jni/JNIApi.c ，然后sync一下即可。 6. rebuild一下，生成so库文件： 三）使用so库1. 新建项目JNIApiSample（为了区分so库的生成过程） 2. 在src/main 目录下新建jniLibs文件夹，并将之前生成的那些so库文件拷贝至jniLibs文件夹中，然后在build.gradle(app目录下)配置： sourceSets { main { jni.srcDirs = [] } } 3. 编写Native接口文件：1234567891011121314151617package com.hawky.jni;/** * @author [*昨日重现*] lhy_ycu@163.com * @since version 1.0 */public class JNIApi &#123; public static native String getStringFromC(); static &#123; try &#123; System.loadLibrary(&amp;quot;JNIApi&amp;quot;); &#125; catch (UnsatisfiedLinkError ule) &#123; System.out.println(&amp;quot;loadLibrary(JNIApi),&amp;quot; + ule.getMessage()); &#125; &#125;&#125; 4. 测试JNI接口：123456789public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toast.makeText(this, &amp;quot;Java调用C代码：&amp;quot; + JNIApi.getStringFromC(), Toast.LENGTH_SHORT).show(); &#125;&#125; rebuild后运行一下可以看到手机界面弹出了“Java调用C代码：I’m String from C!”。OK，大功告成。 总结AS越来越人性化了，gradle3.0之后编写JNI代码也没那么麻烦了，咱们只需要关心具体的核心业务逻辑,专注写C，so库配置一下便会自动生成，然后供Java开发者调用。需要注意的是：JNI接口的包名要与C代码里面的包名一致。]]></content>
      <categories>
        <category>JNI系列</category>
      </categories>
      <tags>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android插件化系列(一)插件化概述]]></title>
    <url>%2F2017%2F08%2F26%2Fpluggable-001%2F</url>
    <content type="text"><![CDATA[Android插件化概述]]></content>
      <categories>
        <category>Android插件化系列</category>
      </categories>
      <tags>
        <tag>Android插件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View系列(一)自定义View概述]]></title>
    <url>%2F2017%2F06%2F26%2Fview-001%2F</url>
    <content type="text"><![CDATA[自定义View系列[1]自定义View概述]]></content>
      <categories>
        <category>自定义View系列</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava系列(一)RxJava概述]]></title>
    <url>%2F2017%2F05%2F26%2Frxjava-001%2F</url>
    <content type="text"><![CDATA[参考rxpalhttps://github.com/hawkyAndroid/rxpal]]></content>
      <categories>
        <category>RxJava系列</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
</search>
