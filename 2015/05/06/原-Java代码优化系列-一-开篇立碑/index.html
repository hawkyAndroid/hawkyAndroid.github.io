<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Hawky的博客" type="application/atom+xml" />






<meta name="description" content="转载请注明出处：http://blog.csdn.net/lhy_ycu/article/details/45506549 在开篇之前，先补充一下《Java学习系列》里面的instanceof关键字的使用及其陷阱。简要说明：instanceof是一个简单的二元操作符，它是用来判断一个对象是否为一个类的实例。只要instanceof左右操作数有继承或实现的关系，程序都是可以编译通过的。下面通过一个简">
<meta property="og:type" content="article">
<meta property="og:title" content="[原]Java代码优化系列(一)开篇立碑">
<meta property="og:url" content="http://hawkyAndroid.github.io/2015/05/06/原-Java代码优化系列-一-开篇立碑/index.html">
<meta property="og:site_name" content="Hawky的博客">
<meta property="og:description" content="转载请注明出处：http://blog.csdn.net/lhy_ycu/article/details/45506549 在开篇之前，先补充一下《Java学习系列》里面的instanceof关键字的使用及其陷阱。简要说明：instanceof是一个简单的二元操作符，它是用来判断一个对象是否为一个类的实例。只要instanceof左右操作数有继承或实现的关系，程序都是可以编译通过的。下面通过一个简">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-10-19T15:39:57.961Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[原]Java代码优化系列(一)开篇立碑">
<meta name="twitter:description" content="转载请注明出处：http://blog.csdn.net/lhy_ycu/article/details/45506549 在开篇之前，先补充一下《Java学习系列》里面的instanceof关键字的使用及其陷阱。简要说明：instanceof是一个简单的二元操作符，它是用来判断一个对象是否为一个类的实例。只要instanceof左右操作数有继承或实现的关系，程序都是可以编译通过的。下面通过一个简">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hawkyAndroid.github.io/2015/05/06/原-Java代码优化系列-一-开篇立碑/"/>





  <title>[原]Java代码优化系列(一)开篇立碑 | Hawky的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hawky的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">行到水穷处，坐看云起时</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hawkyAndroid.github.io/2015/05/06/原-Java代码优化系列-一-开篇立碑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hawky">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hawky的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[原]Java代码优化系列(一)开篇立碑</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-06T02:04:42+08:00">
                2015-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><span style="font-family:Arial; font-size:18px; line-height:26px; text-align:left; color:rgb(255,0,0)">转载请注明出处：</span><a href="http://blog.csdn.net/lhy_ycu/article/details/39721563" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39755577" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39759199" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39784403" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39804057" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805069" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39805735" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39806973" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39828653" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39856435" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39863125" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/39997337" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40008711" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018231" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40018967" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40019829" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40021651" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/40027109" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/45332565" target="_blank" rel="external"></a><a href="http://blog.csdn.net/lhy_ycu/article/details/45506549" target="_blank" rel="external">http://blog.csdn.net/lhy_ycu/article/details/45506549</a></p>
<p>在开篇之前，先补充一下《<a href="http://blog.csdn.net/lhy_ycu/article/details/11935087" target="_blank" rel="external">Java学习系列</a>》里面的instanceof关键字的使用及其陷阱。简要说明：instanceof是一个简单的二元操作符，它是用来判断一个对象是否为一个类的实例。只要instanceof左右操作数有继承或实现的关系，程序都是可以编译通过的。下面通过一个简单实例来说明一下instanceof关键字的使用及其陷阱：</p>
<pre code_snippet_id="659776" snippet_file_name="blog_20150507_1_3672713" name="code" class="java">class A&lt;T&gt; {
    public boolean isDateInstance(T t) {
        return t instanceof Date;
    }
}

public class InstanceofTest {

    public static void main(String[] args) {
        // true。一个String对象是Object实例(java中Object是所有类的父类)
        System.out.println(&quot;zhangsan&quot; instanceof Object);
        // false。Object是父类，它的对象明显不是String类的实例
        System.out.println(new Object() instanceof String);
        // true。一个String对象是String的实例
        System.out.println(new String() instanceof String);
        // 编译不能通过。&#39;a&#39; 为一个char类型，即基本类型
        System.out.println(&#39;a&#39; instanceof Character);
        // false。只要左操作数为null(本质是无类型)，那么结果就直接返回false
        System.out.println(null instanceof String);
        // false。即使将null强转也还是个null
        System.out.println((String) null instanceof String);
        // 编译不能通过。因为Date和String并没有继承或实现关系
        System.out.println(new Date() instanceof String);
        // false。在编译成字节码时，T已经是Object类型了，由于传递了一个&quot;lisi&quot;实参字符串，所以T实际是String类型了。
        System.out.println(new A().isDateInstance(&quot;lisi&quot;));
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        // 编译不能通过。instanceof不允许存在泛型参数。
        System.out.println(list instanceof List&lt;String&gt;);
    }
}</pre>

<p><strong><span style="color:#ff0000">【注意】instanceof只能用于对象的判断，不能用于基本类型的判断。</span></strong></p>
<p>下面开始正式进入主题，先从一个自增的陷阱开始吧。</p>
<h3 id="1）自增的陷阱"><a href="#1）自增的陷阱" class="headerlink" title="1）自增的陷阱"></a>1）自增的陷阱</h3><pre code_snippet_id="659776" snippet_file_name="blog_20150506_2_8462968" name="code" class="java">int num = 0;
for (int i = 0; i &lt; 100; i++) {
    num = num++;
}
System.out.println(&quot;num = &quot; + num);</pre>打印结果是什么呢？答案是0，为什么呢？先看看执行步骤吧，程序第一次循环时的详细步骤如下：JVM把num&#20540;（0）拷贝到临时变量区，然后num&#20540;加1，这是num的&#20540;为1，接着返回临时变量区的&#20540;，注意这个&#20540;是1没修改过，最后将返回&#20540;赋给num，此时num的&#20540;被重置为了0。简单说来就是int temp = num; num &nbsp;&#43;= 1; return temp;这3步。所以打印结果还是0，num始终保持着原来的状态。

**<span style="color:#ff0000">优化：将num=num&#43;&#43;; 修改为num&#43;&#43;即可。</span>**

### 2）常量竟成变量？

大家想想，常量有可能成为变量吗？答案是有可能，只不过这种做法是不被认同的。

<pre code_snippet_id="659776" snippet_file_name="blog_20150506_3_1098375" name="code" class="java">public static final int RAND_CONST = new Random().nextInt();

public static void main(String[] args) {
    // 通过打印几次，可以看到结果变了，也就是说常量在定义的时候就没有保证它的值运行期保持不变
    System.out.println(&quot;常量变了吗？&quot; + RAND_CONST);
}</pre><span style="color:#ff0000">**优化建议：务必常量的&#20540;在运行期保持不变**</span>，所以可以让RAND_CONST在定义时直接赋&#20540;写死。

### 3）“l” 你能看出这个字母是i的大写、数字1还是字母l的小写？

<pre code_snippet_id="659776" snippet_file_name="blog_20150506_4_3939690" name="code" class="java">public static  long l = 11;</pre>

<p><span style="color:#ff0000"><strong>优化：字母后缀l尽量大写L</strong></span></p>
<h3 id="4）三目运算符的类型不一致？"><a href="#4）三目运算符的类型不一致？" class="headerlink" title="4）三目运算符的类型不一致？"></a>4）三目运算符的类型不一致？</h3><pre code_snippet_id="659776" snippet_file_name="blog_20150506_5_2331579" name="code" class="java">int i = 70;
System.out.println(i &lt; 100 ? 80 : 90.0);</pre>打印结果出人意料，结果竟然为80.0，这是为什么呢？i&lt;100确实为true，但由于最后一个操作数为90.0，是一个浮点数，这时编译器会将第二个操作数80转为80.0浮点数，统一结果类型，所以打印结果为80.0。

<span style="color:#ff0000">**优化：90.0改为90**</span>

### **5)不要重载含有变长参数的方法**

简要说明：变长参数必须是方法的最后一个参数，且一个方法不能定义多个变长参数。

<pre code_snippet_id="659776" snippet_file_name="blog_20150506_6_1378935" name="code" class="java">public class Test01 {
    public static void fruitPrice(int price, int discount) {
        float realPrice = price * discount / 100.0F;
        System.out.println(&quot;非变长参数得出的结果：realPrice = &quot; + realPrice);
    }

    public static void fruitPrice(int price, int... discounts) {
        float realPrice = price;
        for (int discount : discounts) {
            realPrice = price * discount / 100.0F;
        }
        System.out.println(&quot;变长参数得出的结果：realPrice = &quot; + realPrice);
    }

    public static void main(String[] args) {
        fruitPrice(48888, 85);
    }
}</pre>

<p>打印结果是什么呢？答案是：非变长参数得出的结果：realPrice = 41554.8，也就是程序执行的是第一个方法，而没有执行变长参数方法，这是为什么呢？因为Java在编译时，首先会根据实参的数量和类型（这里是2个都是int类型的实参，注意没有转成int数组）来进行处理，也就是找到fruitPrice(int price, int discount)方法，而且确认它符合方法签名条件，由于编译器也爱“偷懒”，所以程序会执行第一个方法。再看一个：</p>
<pre code_snippet_id="659776" snippet_file_name="blog_20150506_7_5020306" name="code" class="java">public class Test02 {
    public void method1(String str, Integer... integers) {
        System.out.println(&quot;变长参数类型为Integer的方法被调用...&quot;);
    }

    public void method1(String str, String... strs) {
        System.out.println(&quot;变长参数类型为String的方法被调用...&quot;);
    }

    public static void main(String[] args) {
        Test02 t = new Test02();
        // 编译不通过。虽然两个方法都符合要求，但编译器并不知道调用哪一个，于是就报错了。
        t.method1(&quot;test02&quot;);
        // 编译不通过。因为[直接量null是没有类型的]，理由同上。
        t.method1(&quot;test02&quot;, null);
    }

}</pre>

<p>对于t.method(&quot;test02&quot;,null);如果我们提前声明String[] strs = null或者Integer[] ints = null;也就是让编译器知道这个null是String或者Integer类型的，那么就可以通过编译了。</p>
<h3 id="6）慎用静态导入"><a href="#6）慎用静态导入" class="headerlink" title="6）慎用静态导入"></a>6）慎用静态导入</h3><p>这点比较容易理解，因为静态导入的作用是将某个类的类成员(静态变量、静态方法)引入到本类中，而如果此时刚好本类中也有同名的类成员，那么这样便可能产生混淆，后面维护起来也比较麻烦。</p>
<p><span style="color:#ff0000"><strong>优化：类型.类成员</strong></span></p>
<h3 id="7）-不要让类型默默转换"><a href="#7）-不要让类型默默转换" class="headerlink" title="7） 不要让类型默默转换"></a>7） 不要让类型默默转换</h3><pre code_snippet_id="659776" snippet_file_name="blog_20150506_8_6511518" name="code" class="java">public class Test03 {
    // 光速为30万公公里
    public static final int LIGHT_SPEED = 30 * 10000 * 1000;

    public static void main(String[] args) {
        long distance = 8 * 60 * LIGHT_SPEED;
        // 打印结果(为负数)：地球与太阳的距离为：-2028888064
        System.out.println(&quot;地球与太阳的距离为：&quot; + distance);
    }
}</pre>为什么是负数呢？这是因为**<span style="color:#ff0000">Java是先运算再进行类型转换的</span>**。distance的3个运算参数都是int类型，三者结果相等虽然也是int类型，但已经超过了int取&#20540;的最大范围，所以为负数，这样再转为long型，结果仍是负数。解决方案：long distance = 1L * 8 * 60 * LIGHT_SPEED;1L是个长整型，右边等式类型自动升级，计算出来的结果也是长整型。

**<span style="color:#ff0000">优化：基本类型转换时，最好使用主动声明的方式参与运算。</span>**

### 8）包装类性&#20540;为null?

<pre code_snippet_id="659776" snippet_file_name="blog_20150506_9_5591893" name="code" class="java">public static void main(String[] args) {
    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    // 自动装箱(基本类型转为包装类型)。装箱过程是调用valueOf方法实现的。
    list.add(1);
    list.add(2);
    list.add(null);
    // 自动拆箱(包装类型转为基本类型)。拆箱过程默认调用包装对象的intValue方法实现的。
    int count = 0;
    for (int item : list) {
        count += item;
    }
    System.out.println(&quot;count = &quot; + count);
}</pre>运行结果报异常java.lang.NullPointerException。原因很简单：拆箱过程默认调用包装对象的intValue方法实现的，由于包装类是null&#20540;，所以就报空指针异常了。解决方案：

<pre code_snippet_id="659776" snippet_file_name="blog_20150506_10_2130994" name="code" class="java">for (Integer item : list) {
    count += (item == null) ? 0 : item;
}</pre>

<p><strong><span style="color:#ff0000">优化：包装类型参与运算时，要做null校验。</span></strong></p>
<h3 id="9）让工具类不可实例化"><a href="#9）让工具类不可实例化" class="headerlink" title="9）让工具类不可实例化"></a>9）让工具类不可实例化</h3><p>工具类的方法和属性都是静态的，不需要生成实例即可访问，而且其类成员在内存中只有一份拷贝，jdk也做了很好的处理。由于不希望被初始化，于是就设置其构造函数为私有（private）访问权限。</p>
<pre code_snippet_id="659776" snippet_file_name="blog_20150506_11_749752" name="code" class="java">public class UtilClass {
    // 构造器私有化
    private UtilClass() {

    }
}</pre>但这样有个问题，就是在工具类里面可能方法很多，无意间new了一个新的对象，一时间也没有发现。这样就没有达到真正不需要生成实例的目的。

**<span style="color:#ff0000">优化：使用工具类时，要保证所有的访问都是通过类名进行的。</span>**

<pre code_snippet_id="659776" snippet_file_name="blog_20150506_12_2338382" name="code" class="java">public class UtilClass {
    // 构造器私有化
    private UtilClass() {
        throw new Error(&quot;please don&#39;t instantial this util class...&quot;);
    }
}</pre>

<p>### </p>
<p></p><h3><span style="font-size:14px">10）不要在循环条件中带有计算</span><p></p>
<p><span style="font-weight:normal"><span style="font-size:12px">如果在循环(for、while等)条件中计算，则每次循环都得计算一遍，这样就会降低，例如：</span></span></p>
<p><span style="font-weight:normal"></span><pre code_snippet_id="659776" snippet_file_name="blog_20150507_13_1693939" name="code" class="java">while (n &lt; count * 2) {<br>    //…<br>}</pre></p>
<p><span style="color:#ff0000">优化：将while里面的运算提取即可</span></p></h3><p></p>
<div><pre code_snippet_id="659776" snippet_file_name="blog_20150507_14_4885752" name="code" class="java">int total = count * 2;<br>while (n &lt; total) {<br>    //…<br>}</pre></div>

<h3 id="11）不要主动进行垃圾回收"><a href="#11）不要主动进行垃圾回收" class="headerlink" title="11）不要主动进行垃圾回收"></a>11）不要主动进行垃圾回收</h3><p>尽量不要调用System.gc();来主动对垃圾进行回收。<strong><span style="color:#ff0000">因为System.gc它会停止所有响应，才能检查内存中是否有可回收的对象。把所有对象都检查一遍，然后处理掉那些垃圾对象</span></strong>。这对一个应用系统来说风险极大，如果是一个web项目，调用System.gc它会让所有的请求都暂停，等待垃圾回收器执行完毕(可能会严重影响正常业务运行)，如果web项目里面对象很多，那么System.gc执行的时间会非常耗时，所以最好不要主动进行垃圾回收。</p>
<h3 id="12）静态变量一定要先声明后赋-20540-（或使用）"><a href="#12）静态变量一定要先声明后赋-20540-（或使用）" class="headerlink" title="12）静态变量一定要先声明后赋&#20540;（或使用）"></a>12）静态变量一定要先声明后赋&#20540;（或使用）</h3><p><pre code_snippet_id="659776" snippet_file_name="blog_20150506_13_6720943" name="code" class="java">public class Test01 {<br>    static {<br>        num = 20;<br>    }<br>    public static int num = 2;</pre></p>
<pre><code>public static void main(String[] args) {
    System.out.println(num);
}
</code></pre><p>}大家想想，结果是多少呢？打印结果是：2。为什么呢？这是因为静态变量(类变量)是类加载时被分配到数据区，<strong><span style="color:rgb(255,0,0)">它在内存中只有一份拷贝，</span></strong>详细说来就是：<span style="color:#ff0000">静态变量是在类初始化时首先被加载的，而JVM会去查找类中所有的静态声明，然后分配地址空间(此时还没有赋&#20540;)，之后JVM会根据类中静态赋&#20540;（包括静态类赋&#20540;和静态代码块赋&#20540;）的先后顺序来执行</span>。</p>
<p><strong><span style="color:#ff0000">优化：静态变量先声明后使用。</span></strong></p>
<h2 id="补充1——字符串常量池"><a href="#补充1——字符串常量池" class="headerlink" title="补充1——字符串常量池"></a>补充1——字符串常量池</h2><p>大家都知道，Java中的对象是保存在堆内存中的，但是字符串(常量)池非常特殊，<strong><span style="color:rgb(255,0,0)">它在编译期就已经决定了其存在JVM的常量池中，垃圾回收器是不会对它进行回收的</span></strong>。它的创建机制是这样的：创建一个字符串时，首先检查池中是否有字符序列相等的字符串，如果有则不再创建，直接返回池中该对象的引用；若没有则创建之，然后放入池中并返回创建对象的引用。下面看一个实例：</p>
<p><pre code_snippet_id="659776" snippet_file_name="blog_20150507_16_5979086" name="code" class="java">public class Test {<br>    public static void main(String[] args) {<br>        String str1 = &quot;java代码优化&quot;;<br>        String str2 = &quot;java代码优化&quot;;<br>        String str3 = new String(&quot;java代码优化&quot;);<br>        String str4 = str3.intern();</pre></p>
<pre><code>    System.out.println(str1 == str2);
    System.out.println(str1 == str3);
    System.out.println(str1 == str4);
}
</code></pre><p>}结果是什么呢？答案是true、false、true。解析：创建第一个字符串&quot;java代码优化&quot;时，首先检查字符串池中是否有该对象，发现没有，于是就创建第一个&quot;java代码优化&quot;这个字符串并放入池中，待再创建str2字符串时，由于池中已经有了该字符串，于是就直接返回了该对象的引用，此时str1与str2指向的是同一个地址，所有str1==str2返回true。而new String(&quot;java代码优化&quot;)声明的是一个String对象，是不检查字符串池，也不会把对象放入池中，那当然返回false了。而使用intern方法为什么会返回true呢？因为intern会检查当前对象在池中是否有字符序列相等的引用对象，如果有则返回true，如果没有则返回false。</p>
<p><strong><span style="color:rgb(255,0,0)">优化建议：若没有特殊要求，推荐使用String直接量赋&#20540;</span></strong></p>
<h3 id="补充2——String、StringBuffer（线程安全）、StringBuilder-线程不安全-的使用场景"><a href="#补充2——String、StringBuffer（线程安全）、StringBuilder-线程不安全-的使用场景" class="headerlink" title="补充2——String、StringBuffer（线程安全）、StringBuilder(线程不安全)的使用场景"></a>补充2——String、StringBuffer（线程安全）、StringBuilder(线程不安全)的使用场景</h3><p>①String的使用场景：在字符串不经常变化的场景中使用String类，例如常量的声明、少量的变量运算等。</p>
<p>②StringBuffer的使用场景：在频繁进行字符串运算（如：字符串拼接、替换、删除等），并且运行在多线程环境中，则可以考虑使用StringBuffer，例如：XML解析、HTTP参数解析和封装等。</p>
<p>③StringBuilder的使用场景：在频繁进行字符串运算（如：字符串拼接、替换、删除等），并且运行在单线程环境中，则可以考虑使用StringBuilder，例如：SQL语句的封装、JSON封装等。</p>
<p>参考文献：《编写高质量代码》</p>
<pre><code>&lt;div&gt;
    作者：JAVE_LOVER 发表于2015/5/6 2:04:42 [原文链接](http://blog.csdn.net/lhy_ycu/article/details/45506549)
&lt;/div&gt;
&lt;div&gt;
阅读：1555 评论：0 [查看评论](http://blog.csdn.net/lhy_ycu/article/details/45506549#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/05/05/原-Java学习系列-二十四-Java正则表达式详解/" rel="next" title="[原]Java学习系列(二十四)Java正则表达式详解">
                <i class="fa fa-chevron-left"></i> [原]Java学习系列(二十四)Java正则表达式详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/05/08/原-Java学习系列博客全目录/" rel="prev" title="[原]Java学习系列博客全目录">
                [原]Java学习系列博客全目录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="Hawky" />
            
              <p class="site-author-name" itemprop="name">Hawky</p>
              <p class="site-description motion-element" itemprop="description">爱好爬山、旅游、分享</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）自增的陷阱"><span class="nav-number">1.</span> <span class="nav-text">1）自增的陷阱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）三目运算符的类型不一致？"><span class="nav-number">2.</span> <span class="nav-text">4）三目运算符的类型不一致？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6）慎用静态导入"><span class="nav-number">3.</span> <span class="nav-text">6）慎用静态导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7）-不要让类型默默转换"><span class="nav-number">4.</span> <span class="nav-text">7） 不要让类型默默转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9）让工具类不可实例化"><span class="nav-number">5.</span> <span class="nav-text">9）让工具类不可实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">6.</span> <span class="nav-text">10）不要在循环条件中带有计算
如果在循环(for、while等)条件中计算，则每次循环都得计算一遍，这样就会降低，例如：
while (n < count * 2) {    //…}
优化：将while里面的运算提取即可</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11）不要主动进行垃圾回收"><span class="nav-number">7.</span> <span class="nav-text">11）不要主动进行垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12）静态变量一定要先声明后赋-20540-（或使用）"><span class="nav-number">8.</span> <span class="nav-text">12）静态变量一定要先声明后赋值（或使用）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充1——字符串常量池"><span class="nav-number"></span> <span class="nav-text">补充1——字符串常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#补充2——String、StringBuffer（线程安全）、StringBuilder-线程不安全-的使用场景"><span class="nav-number">1.</span> <span class="nav-text">补充2——String、StringBuffer（线程安全）、StringBuilder(线程不安全)的使用场景</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hawky</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  








  












  





  

  

  
  

  

  

  

</body>
</html>
